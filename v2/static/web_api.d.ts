// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../gl-matrix
//   ../../../web_app/device
//   ../../../core3d/shaders

declare module '@novorender/api' {
    export * from "@novorender/api/web_app";
}

declare module '@novorender/api/web_app' {
    export * from "@novorender/api/core3d";
    export * from "@novorender/api/web_app/device";
    export * from "@novorender/api/web_app/view";
    export * from "@novorender/api/web_app/controller";
    export * from "@novorender/api/web_app/serviceWorker";
    export * from "@novorender/api/web_app/highlight";
    export * from "@novorender/api/web_app/geometry";
    /**
      * NPM package version, if applicable.
      */
    export const packageVersion: any;
}

declare module '@novorender/api/core3d' {
    /**
      * The Core3D module loads and renders 3D assets.
      *
      * @packageDocumentation
      */
    export * from "@novorender/api/core3d/init";
    export * from "@novorender/api/core3d/state";
    export * from "@novorender/api/core3d/context";
    export * from "@novorender/api/core3d/modules";
    export * from "@novorender/api/core3d/device";
    export * from "@novorender/api/core3d/imports";
    export * from "@novorender/api/core3d/benchmark";
    export * from "@novorender/api/core3d/wasm";
    export { downloadScene } from "@novorender/api/core3d/scene";
    export { downloadGLTF } from "@novorender/api/core3d/gltf";
}

declare module '@novorender/api/web_app/device' {
    import type { DeviceProfile } from "@novorender/api/core3d";
    /**
        * GPU performance tier.
        * @remarks
        * This is a rough estimate of the capabilities of a device GPU.
        * 0 is weakest and 3 is strongest.
        * As a general guide, these are the targets for the different tiers:
        * - 0: Unknown GPU - A weak android device. Also the fallback tier for unknown GPUs.
        * - 1: IOS, IPad, high-end android device, weak integrated (intel) GPU
        * - 2: Mac M1 or better, strong integrated GPU or weak/old discrete GPU.
        * - 3: Discrete GPU, mid to high end.
        * @category Device Profile
        */
    export type GPUTier = 0 | 1 | 2 | 3;
    /**
        * Create a device profile.
        * @param tier The performance level of device GPU, 0-3, where 0 is weakest.
        * @param resolutionScaling An optional scale factor to apply to output image resolution.
        * @returns A {@link DeviceProfile} reflecting the typical capabilities of a GPU at given tier level.
        * @remarks
        * A simple tier system is probably too simplistic but provides a starting point.
        * The resulting device profile may be modified further before passing it into the {@link View} constructor.
        * @category Device Profile
        */
    export function getDeviceProfile(tier: GPUTier, resolutionScaling?: number): DeviceProfile;
}

declare module '@novorender/api/web_app/view' {
    import { type ReadonlyVec3, vec3, type ReadonlyQuat } from "gl-matrix";
    import { type RenderState, type RenderStateChanges, RenderContext, type SceneConfig, type RenderStatistics, type DeviceProfile, type PickSample, type PickOptions, type Core3DImports } from "@novorender/api/core3d";
    import { ControllerInput, type BaseController, type PickContext, type BuiltinCameraControllerType } from "@novorender/api/web_app/controller";
    /**
        * A view base class for Novorender content.
        * @template CameraControllerType Types of camera controllers used by this view.
        * @template CameraControllerKind The inferred camera controller kind string union.
        * @remarks
        * The view class wraps the complexities of the `Core3D` module into a high-level abstraction.
        * Notably, it implements a render loop in the {@link run} function, which deals with a number of issues, such as:
        * - Camera controllers.
        * - Rendering after {@link modifyRenderState | state changes}, saving energy and battery life.
        * - Adjust to resizing of canvas element.
        * - Managing idle vs active rendering, i.e. lower fidelity rendering while the camera is moving for better frame rates.
        * - Adaptive performance adjustment to maintain a target frame rate target.
        * - Post effects.
        *
        * In the likely event that you want to change or extend some of the default behaviour,
        * you should make a derived View class of your own and override the methods you need.
        * @category Render View
        */
    export class View<CameraControllerTypes extends CameraControllers = BuiltinCameraControllerType, CameraControllerKind extends string = Extract<keyof CameraControllerTypes, string>> {
            /** The HTMLCanvasElement used for rendering. */
            readonly canvas: HTMLCanvasElement;
            /** The url from which the javascript containing this class was loaded. */
            readonly scriptUrl: string;
            /** Available camera controller types. */
            controllers: CameraControllerTypes;
            /**
                * @param canvas The HtmlCanvasElement used for rendering.
                * @param deviceProfile The device profile describing the host device's GPU performance characteristics and limitations.
                * @param imports Imported, non-javascript resources.
                * @remarks
                * Your browser must run in a {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | secure}
                * and {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | cross-origin isolated } context.
                */
            constructor(
            /** The HTMLCanvasElement used for rendering. */
            canvas: HTMLCanvasElement, deviceProfile: DeviceProfile, imports: Core3DImports, controllersFactory?: CameraControllersFactory<CameraControllerTypes>);
            /** Dispose of the view's GPU resources. */
            dispose(): void;
            get activeController(): BaseController;
            get renderContext(): RenderContext | undefined;
            get renderState(): RenderState;
            get prevRenderState(): RenderState | undefined;
            get statistics(): {
                    readonly render: RenderStatistics;
                    readonly view: ViewStatistics;
            } | undefined;
            /**
                * The current device profile.
                * @remarks
                * Setting a new device profile will force a recreation of the entire render context and should generally be avoided.
                * Valid cases for doing so might be users manually overriding the GPU profile of their device, or for testing/diagnostics purposes.
                */
            get deviceProfile(): DeviceProfile;
            set deviceProfile(value: DeviceProfile);
            /** Determine if camera is looking straight down. */
            isTopDown(): boolean;
            /**
                * Convert 2D pixel position to 3D position.
                * @param x Pixel x coordinate, in CSS pixels.
                * @param y Pixel y coordinate, in CSS pixels.
                * @returns Corresponding 3D position at the view plane in world space, or undefined if there is no active render context.
                */
            worldPositionFromPixelPosition(x: number, y: number): vec3 | undefined;
            /**
                * Retrieve list of available background/IBL environments.
                * @public
                * @param indexUrl
                * The absolute or relative url of the index.json file.
                * Relative url will be relative to the novorender api script url.
                * If undefined, "/assets/env/index.json" will be used by default.
                * @returns A promise of a list of environments.
                */
            availableEnvironments(indexUrl?: string): Promise<EnvironmentDescription[]>;
            /**
                * Load a scene from a url.
             * @public
             * @param url The absolute url to the folder containing the scene.
             * @remarks
             * The url typically contains the scene id as the latter part of the path, i.e. `https://.../<scene_guid>/`.
             */
            loadSceneFromURL(url: URL): Promise<SceneConfig>;
            /**
                * Query object and geometry information for given view coordinate.
                * @param x Center x coordinate in css pixels.
                * @param y Center y coordinate in css pixels.
                * @param options Extra options.
                * @returns The sample within the sample disc that is closest to the camera, if any.
                */
            pick(x: number, y: number, options?: PickOptions): Promise<PickSampleExt | undefined>;
            /**
                * Switch to a new kind of camera controller.
                * @param kind The type of camera controller to switch to.
                * @param initialState Optional initial state for the new camera controller. Undefined properties will be copied/adapted from the current render state.
                * @param options Switch options.
                * @template T Kind of camera controller.
                * @returns The new camera controller.
                * @remarks
                * The function will also set the {@link RenderStateCamera.kind | camera projection model}.
                */
            switchCameraController<T extends CameraControllerKind>(kind: T, initialState?: CameraControllerInitialValues, options?: CameraControllerOptions): Promise<CameraControllerTypes[T]>;
            /**
                * Start the main render loop for the view.
                * @param abortSignal Signal to abort any pending downloads and exit render loop.
                * @remarks
                * This method will not exit until you call {@link exit}.
                */
            run(abortSignal?: AbortSignal): Promise<void>;
            /** Signal the render loop to exit.
                * @see {@link run}.
                * @deprecated Use {@link run} `abortSignal` instead.
                */
            exit(): void;
            /** Accumulate render state changes without validation.
                * @param changes The changes to apply to the current view render state.
                * @remarks
                * This function is useful to batch up multiple render state changes without the overhead of validation.
                * These changes will be applied and validated in a single call to the {@link modifyRenderState} function just prior to rendering each frame.
                */
            modifyRenderState(changes: RenderStateChanges): void;
            /**
                * Override this in a derived class to modify render state just prior to rendering.
                * @param time The frame render timestamp in millisecond.
                * @virtual
                */
            animate?(time: number): void;
            /**
                * Override this in a derived class for custom rendering of e.g. 2D content, such as text and lines etc.
                * @param isIdleFrame Was the camera moving or not.
                * @virtual
                */
            render?(isIdleFrame: boolean): void;
            /**
                * Callback function to update render context.
                * @param context A new render context.
                * @remarks
                * A new render context may be set each time the underlying webgl context is lost and restored,
                * or when certain state changes are made that forces a recreation of the context, such as setting a new {@link deviceProfile}.
                * @virtual
                */
            protected readonly setRenderContext: (context: RenderContext) => void;
    }
    /** Background/IBL environment description
        * @category Render View
        */
    export interface EnvironmentDescription {
            /** Display name of environment */
            readonly name: string;
            /** Data URL. */
            readonly url: string;
            /** Thumbnail URL. */
            readonly thumnbnailURL: string;
    }
    /** View related render statistics.
        * @category Render View
        */
    export interface ViewStatistics {
            /** Effective resolution factor. */
            readonly resolution: number;
            /** Effective detail bias factor. */
            readonly detailBias: number;
            /** Effective frames per second, if available. */
            readonly fps?: number;
    }
    /** Extended pick sample information.
        * @category Render View
        */
    export interface PickSampleExt extends PickSample {
            /** Sample normal, in view space. */
            readonly normalVS: ReadonlyVec3;
            /** Whether sample lies on an edge, corner or surface. */
            readonly sampleType: "edge" | "corner" | "surface";
    }
    /** @ignore */
    export type CameraControllers<T extends string = string> = {
            readonly [P in T]: BaseController;
    };
    /** Camera controller factory function signature type.
        * @template T dude
        */
    export type CameraControllersFactory<T extends CameraControllers> = (input: ControllerInput, pick: PickContext) => T;
    /** Optional values to initialize camera controller. */
    export interface CameraControllerInitialValues {
            /** The camera position. */
            readonly position?: ReadonlyVec3;
            /** The camera rotation. */
            readonly rotation?: ReadonlyQuat;
            /** The camera field of view.
                * @see {@link RenderStateCamera.fov}.
                */
            readonly fov?: number;
    }
    /** Camera controller switch options.
        * @category Camera Controller
        * @category Render View
        */
    export interface CameraControllerOptions {
            /** Whether to attempt an auto initializion of camera position or not.
                * @remarks
                * This is a heuristic won't work well for scenes with clusters of geometry scattered far apart.
                * Georeferenced autocad models that contains "meta" geometry at origo are often problematic and may require you to supply a position manually.
                */
            readonly autoInit?: boolean;
    }
}

declare module '@novorender/api/web_app/controller' {
    export * from "@novorender/api/web_app/controller/builtin";
    export * from "@novorender/api/web_app/controller/input";
    export * from "@novorender/api/web_app/controller/base";
    export * from "@novorender/api/web_app/controller/orbit";
    export * from "@novorender/api/web_app/controller/ortho";
    export * from "@novorender/api/web_app/controller/flight";
    export * from "@novorender/api/web_app/controller/panorama";
    export * from "@novorender/api/web_app/controller/null";
    export { computeRotation, rotationFromDirection } from "@novorender/api/web_app/controller/orientation";
}

declare module '@novorender/api/web_app/serviceWorker' {
    export * from "@novorender/api/web_app/serviceWorker/helper";
    export * from "@novorender/api/web_app/serviceWorker/promiseBag";
}

declare module '@novorender/api/web_app/highlight' {
    import type { AtLeastOne, RGB, RGBA, RGBATransform } from "@novorender/api/core3d/state";
    /**
        * Create a highlight color transform that doesn't change colors.
        * @category Render State
        */
    export function createNeutralHighlight(): RGBATransform;
    /**
        * Create a highlight color transform that replaces material opacity.
        * @param opacity New material opacity between 0 and 1, where 0 is 100% transparent and 1.0 is 100% opaque.
        * @category Render State
        */
    export function createTransparentHighlight(opacity: number): RGBATransform;
    /**
        * Create a highlight color transform that replaces material colors.
        * @param color New material color or color modifier with optional alpha to be used uniformly across selection.
        * @category Render State
        */
    export function createColorSetHighlight(color: RGB | RGBA): RGBATransform;
    /**
        * Create a highlight color transform that modifies material colors.
        * @param color New material color or color modifier with optional alpha.
        * @remarks
        * Colors can either be replaced or modified using the {@link LinearTransform}.
        * @category Render State
        */
    export function createRGBATransformHighlight(options: AtLeastOne<RGBAOptions>): RGBATransform;
    /**
        * Create a highlight color transform that modifies material colors using hue, saturation and lightness.
        * @param color New material hue, saturation and lightness modifier with optional alpha.
        * @category Render State
        */
    export function createHSLATransformHighlight(options: AtLeastOne<HSLAOptions>): RGBATransform;
    /** Options for RGBA + alpha color transformation.
        * @remarks
        * All input values are between 0 and 1.
        * @category Render State
        */
    export interface RGBAOptions {
            /** Red color adjustment. */
            readonly red: number | LinearTransform;
            /** Green color adjustment. */
            readonly green: number | LinearTransform;
            /** Blue color adjustment. */
            readonly blue: number | LinearTransform;
            /** Opacity/alpha adjustment. */
            readonly opacity: number | LinearTransform;
    }
    /** Options for HSL + alpha color transformation.
        * @remarks
        * All input values are between 0 and 1.
        * See {@link https://en.wikipedia.org/wiki/HSL_and_HSV | Wikipedia} for more details on the HSV color space.
        * @category Render State
        */
    export interface HSLAOptions {
            /** Lightness adjustment. */
            readonly lightness: number | LinearTransform;
            /** Saturation adjustment (scale). */
            readonly saturation: number;
            /** Opacity/alpha adjustment. */
            readonly opacity: number | LinearTransform;
    }
    /** Linear transform options.
        * @remarks
        * The transform is performed by first applying scale, then adding offset, i.e.: result = value * scale + offset.
        * If scale = 0, offset will effectively replace input value.
        * @category Render State
        */
    export interface LinearTransform {
            /** Multiplicand for input value. Default = 1.*/
            readonly scale?: number;
            /** Addend for scaled input value. Default = 0. */
            readonly offset?: number;
    }
}

declare module '@novorender/api/web_app/geometry' {
    import type { RenderStateDynamicMaterial, RenderStateDynamicObject } from "@novorender/api/core3d/state";
    /**
        * Create a simple cube mesh object.
        * @param material The material to use, or undefined for default material.
        * @example
        * ```typescript
        * const cube = createCubeObject();
        * view.modifyRenderState({ dynamic: { objects: [cube] } });
        * ```
        * @category Geometry
        * @experimental
        */
    export function createCubeObject(material?: RenderStateDynamicMaterial): RenderStateDynamicObject;
    /**
        * Create a simple sphere mesh object.
        * @param detail The level of tesselation, expressed as # subdivisions of the base icosahedron.
        * @param material The material to use, or undefined for default material.
        * @example
        * ```typescript
        * const sphere = createSphereObject();
        * view.modifyRenderState({ dynamic: { objects: [sphere] } });
        * ```
        * @category Geometry
        * @experimental
        */
    export function createSphereObject(detail?: number, material?: RenderStateDynamicMaterial): RenderStateDynamicObject;
}

declare module '@novorender/api/core3d/init' {
    import type { DeviceProfile } from "@novorender/api/core3d";
    import { RenderContext } from "@novorender/api/core3d/context";
    import type { Core3DImports } from "@novorender/api/core3d/imports";
    /**
      * Create and initialize the core 3D render context.
      * @param deviceProfile Details about the device on which we're running.
      * @param canvas The html canvas to render to.
      * @param imports Non-js resource imports.
      * @param setRenderContext A callback function to call whenever the render context changes.
      * @returns A method to explicitly set new device profile (from user input or debugging purposes).
      * This is a relatively low-level API that is aimed at advanced developers only.
      * You should call this method once for each view that you wish to render.
      * It will not return a {@link RenderContext} immediately, since that object is tied to a WebGLRenderingContext, which can be lost and recreated.
      * Instead it will call your setback function, either when the render context is ready or restored.
      * You can check {@link RenderContext.isContextLost} to see if the underlying WebGLRenderingContext is lost or not.
      * Changes to device profile will force a recreation of the entire context and should generally be avoided.
      * @category Render View
      */
    export function initCore3D(deviceProfile: DeviceProfile, canvas: HTMLCanvasElement, imports: Core3DImports, setRenderContext: (context: RenderContext) => void): (value: DeviceProfile) => Promise<void>;
}

declare module '@novorender/api/core3d/state' {
    import type { ReadonlyQuat, ReadonlyVec3, ReadonlyVec4, ReadonlyMat4, ReadonlyMat3 } from "gl-matrix";
    import type { RGB, RGBA, FixedSizeArray, RecursivePartial } from "@novorender/api/core3d/state/types";
    import type { RenderStateScene } from "@novorender/api/core3d/state/scene";
    import type { RenderStateDynamicObjects } from "@novorender/api/core3d/state/dynamic";
    export * from "@novorender/api/core3d/state/dynamic";
    export * from "@novorender/api/core3d/state/types";
    export * from "@novorender/api/core3d/state/scene";
    export * from "@novorender/api/core3d/state/default";
    export * from "@novorender/api/core3d/state/modify";
    /**
        * An object describing the what to be rendered and how by {@link RenderContext.render}.
        * @remarks
        * The render state is immutable by design.
        * You should not attempt to mutate existing objects.
        * The correct way to change render state is to use the {@link modifyRenderState} function.
        * This function will create a new copy of objects with new/modified properties, while retaining all objects that hasn't changed.
        * It will also perform basic validation.
        * The engine uses {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality | strict equality} to determine if some portion of the state has changed.
        * Hence, it's important that unchanged sub objects are not copied.
        *
        * The render state is serializable via JSON or {@link https://developer.mozilla.org/en-US/docs/Web/API/structuredClone | structuredClone()}.
        * This can be useful for test/diagnostics purposes, since the render state should define how the output image eventually is rendered.
        * It may take a while for downloads of streamed resources to complete, however, so the output image will not be fully resolved until all pending downloads are complete.
        * There are also other runtime factors, such as device specific limitations or variations, that may contribute to small deviations in the output image.
        * A direct pixel to pixel comparison between two output images generated by identical render state is thus likely to fail unless it's rendered on the same device and same version of our API, browser, OS and drivers.
        * @category Render State
        */
    export interface RenderState {
            /** Output image related state. */
            readonly output: RenderStateOutput;
            /** background/environment related state. */
            readonly background: RenderStateBackground;
            /** camera related state. */
            readonly camera: RenderStateCamera;
            /** Render quality related state. */
            readonly quality: RenderStateQuality;
            /** Grid helper related state. */
            readonly grid: RenderStateGrid;
            /** @ignore */
            readonly debug: RenderStateDebug;
            /** Static, streamable scene related state. */
            readonly scene: RenderStateScene | undefined;
            /** Terrain rendering related state. */
            readonly terrain: RenderStateTerrain;
            /** Dynamic objects related state. */
            readonly dynamic: RenderStateDynamicObjects;
            /** Clipping planes related state. */
            readonly clipping: RenderStateClipping;
            /** Highlights related state. */
            readonly highlights: RenderStateHighlightGroups;
            /** Outlines related state. */
            readonly outlines: RenderStateOutlines;
            /** Tonemapping related state. */
            readonly tonemapping: RenderStateTonemapping;
            /** Point cloud rendering related state. */
            readonly points: RenderStatePointCloud;
            /** Toon outline rendering related state. */
            readonly toonOutline: RenderStateToonOutline;
            /** Pick info rendering related state. */
            readonly pick: RenderStatePick;
    }
    /** An extended variant of RenderState with additional derived properties.
        * @category Render State
        */
    export interface DerivedRenderState extends RenderState {
            /** Local space is a variant of world space that is close to camera to avoid excessively large coordinates and thus float32 rounding errors in shader. */
            readonly localSpaceTranslation: ReadonlyVec3;
            /** The set of matrices that used to transform coordinate between spaces. */
            readonly matrices: Matrices;
            /** The 6 planes of the view frustum, defined in world space. */
            readonly viewFrustum: ViewFrustum;
            /** The effective number of MSAA samples uses for this frame.
                * @remarks This originates from {@link RenderStateOutput.samplesMSAA} but is potentially capped to the device's MSAA sample limit.
                */
            readonly effectiveSamplesMSAA: number;
    }
    /** A partial view of render state used for modifications.
        * @category Render State
        */
    export type RenderStateChanges = RecursivePartial<RenderState>;
    /** The 6 planes of a {@link https://en.wikipedia.org/wiki/Viewing_frustum | view frustum}, defined in world space.
        * @remarks
        * Planes are defined as 4D {@link https://en.wikipedia.org/wiki/Half-space_(geometry) | half-space} vectors.
        * Points are inside the halfspace when the dot product of the half-space vector and a 4D variant of the point with w=1 is negative.
        *
        * `inside = dot(vec4(point, 1.), plane) < 0.;`
        * @category Render State
        */
    export interface ViewFrustum {
            /** The left screen edge plane of the frustum */
            readonly left: ReadonlyVec4;
            /** The right screen edge plane of the frustum */
            readonly right: ReadonlyVec4;
            /** The top screen edge plane of the frustum */
            readonly top: ReadonlyVec4;
            /** The bottom screen edge plane of the frustum */
            readonly bottom: ReadonlyVec4;
            /** The camera's near clipping plane. */
            readonly near: ReadonlyVec4;
            /** The camera's far clipping plane. */
            readonly far: ReadonlyVec4;
            /** A plane coincident with camera position and parallel to screen/image plane in world space. */
            readonly image: ReadonlyVec4;
            /** All tuple of all planes used for {@link https://en.wikipedia.org/wiki/Hidden-surface_determination#Viewing-frustum_culling | culling}. */
            readonly planes: readonly [left: ReadonlyVec4, right: ReadonlyVec4, top: ReadonlyVec4, bottom: ReadonlyVec4, near: ReadonlyVec4, far: ReadonlyVec4];
    }
    /** Transformation coordinate space.
        * @see {@link https://learnopengl.com/Getting-started/Coordinate-Systems}.
        * @category Render State
        */
    export enum CoordSpace {
            /** World space. */
            World = 0,
            /** View space. */
            View = 1,
            /** Clip space. */
            Clip = 2
    }
    /** A helper object for computing transformation matrices between {@link CoordSpace | spaces} on demand.
        * @category Render State
        */
    export interface Matrices {
            /**
                * Return a 4x4 matrix for transforming coordinate from one space to another.
                * @param from The original space.
                * @param to The destination space.
                */
            getMatrix(from: CoordSpace, to: CoordSpace): ReadonlyMat4;
            /**
                * Return a 3X3 matrix for transforming normals from one space to another.
                * @param from The original space.
                * @param to The destination space.
                * @remarks
                * Normals has to be normalized after transformation.
                */
            getMatrixNormal(from: CoordSpace, to: CoordSpace): ReadonlyMat3;
    }
    /** Output image related state.
        * @category Render State
        */
    export interface RenderStateOutput {
            /** Image pixel width. */
            readonly width: number;
            /** Image pixel height. */
            readonly height: number;
            /** Number of {@link https://en.wikipedia.org/wiki/Multisample_anti-aliasing | MSAA} samples used to anti-alias the output image.
                * @remarks
                * This number should be an integer between 1 and 16, inclusive.
                * The more samples, the better the anti aliasing, but also the more memory and render time.
                * Most devices have a max cap on this value, in which case that smaller of the two will be used.
                */
            readonly samplesMSAA: number;
    }
    /** Background/environment related render state.
        * @category Render State
        */
    export interface RenderStateBackground {
            /** The background color to be used if no url is specified.
                * @remarks
                * If undefined, the default background will be used instead.
                * If alpha < 1, the rendered image will be transparent, which could be useful for 2D compositing.
                */
            readonly color?: RGBA;
            /** The url of the background/environment.
                * @remarks
                * This should point to the folder that contains the textures files of the desired environment, e.g. `https://api.novorender/env/lake/'.
                */
            readonly url?: string;
            /** A blur factor to use when rendering the background image.
                * @remarks
                * 0 will yield no blur, while 1 will yield max blur.
                * Blurring is useful for not overly cluttering up the image with backgrounds while still retaining the ambience and lighting characteristics.
                */
            readonly blur?: number;
    }
    /** Camera related render state.
        * @category Render State
        */
    export interface RenderStateCamera {
            /** The type of camera projection to use.
                * @see
                * {@link https://en.wikipedia.org/wiki/Pinhole_camera_model | pinhole}
                * {@link https://en.wikipedia.org/wiki/Orthographic_projection | orthographic}
                */
            readonly kind: "pinhole" | "orthographic";
            /** Camera position in world space. */
            readonly position: ReadonlyVec3;
            /** Camera rotation in world space.
                * @remarks
                * This rotation is from camera->world space, much like that of a local->world space transformation of any rendered object.
                * It should not be confused with the inverse transformation, i.e. world->camera space, commonly used in shaders.
                */
            readonly rotation: ReadonlyQuat;
            /** Camera pivot point in world space.
                * @remarks
                * This is used to visualize a point around which the camera will pivot when moved.
                * (Currently not implemented)
                */
            readonly pivot: ReadonlyVec3 | undefined;
            /** Camera's vertical field of view.
                * @remarks
                * For pinhole cameras, this value is interpreted as the angle between the top and bottom edge of the frustum in degrees.
                * For orthographic cameras, this value is interpreted as the distance between the top and bottom edge of the view frustum in meters.
                */
            readonly fov: number;
            /** Camera's near clipping plane distance.
                * @remarks
                * This value must be larger than 0, preferable as large as it can comfortable be without excessive visual clipping artifacts.
                * Any pixels that are closer to the image plane will be clipped.
                * Larger values will greatly improve z-buffer resolution,
                * which helps reduce {@link https://en.wikipedia.org/wiki/Z-fighting | z-fighting}.
                */
            readonly near: number;
            /** Camera's far clipping plane distance.
                * @remarks
                * This value must be larger than the {@link near} clipping plane.
                * Any pixels that are farther away from the image plane will be clipped.
                * Smaller values improves z-buffer resolution, which helps reduce {@link https://en.wikipedia.org/wiki/Z-fighting | z-fighting}.
                * Smaller values also increases the # objects culled, which could help improve rendering performance.
                */
            readonly far: number;
    }
    /** Quality related render state.
        * @category Render State
        */
    export interface RenderStateQuality {
            /**
                * A detail bias factor used to modify the acceptable geometric error, and consequently the amount of geometric detail.
                * @remarks
                * The value must be larger than 0.
                * 1.0 is the baseline value.
                * Lower values will reduce geometric detail, but also improve performance and memory usage.
                * Higher values will increase geometric detail, at the cost of performance and memory consumption.
                * At some point the amount of detail is capped by device specific constraints.
                */
            readonly detail: number;
    }
    /** Grid related render state.
        * @category Render State
        */
    export interface RenderStateGrid {
            /** Turn grid on and off.*/
            readonly enabled: boolean;
            /** Color of minor grid lines.*/
            readonly color1: RGB;
            /** Color of major grid lines.*/
            readonly color2: RGB;
            /** The grid's origin/center coordinate in world space.*/
            readonly origin: ReadonlyVec3;
            /** The grid's x-axis in world space.*/
            readonly axisX: ReadonlyVec3;
            /** The grid's y-axis in world space.*/
            readonly axisY: ReadonlyVec3;
            /** Minor grid cell size
                * @defaultValue 1
                */
            readonly size1: number;
            /** Major grid cell size
                * @defaultValue 10
                */
            readonly size2: number;
            /** Max distance to render grid in meters. */
            readonly distance: number;
    }
    /** Gradient curve knot node.
        * @category Render State
        */
    export interface RenderStateColorGradientKnot<T extends RGB | RGBA> {
            /** Knot position on the gradient ramp. */
            readonly position: number;
            /** Color to use at this gradient position. */
            readonly color: T;
    }
    /** A color gradient curve.
        * @remarks
        * This curve is used to visualize some scalar value as a color gradient, e.g. terrain evelvation or point cloud devience.
        * @category Render State
        */
    export interface RenderStateColorGradient<T extends RGB | RGBA> {
            /**A set of knots defining a non-uniform linear spline curve.
                * @remarks
                * Nodes must be sorted in ascending order of elevation!
                * At least two nodes are required for any sort of gradient.
                * Nodes do not have to be uniformly distributed elevation-wise.
                * To create a discontinuity in the gradient, two adjacent nodes with identical elevation, but different colors may be used.
                * Any elevation outside the min/max range defined by this list will be clamped to the color of the nearest node (min or max), i.e., no extrapolation will occur.
                */
            readonly knots: readonly RenderStateColorGradientKnot<T>[];
    }
    /** Terrain render state.
        * @category Render State
        */
    export interface RenderStateTerrain {
            /** Elevation gradient color curve.
                * @remarks
                * Elevations are defined as in meters above/below sea level (using negative values for sub sea terrain).
                */
            readonly elevationGradient: RenderStateColorGradient<RGB>;
            /** Flag for whether to draw terrain as background. */
            readonly asBackground: boolean;
    }
    /** Point cloud related render state.
        * @remarks
        * The sizes are cumulative and computed as follows:
        * ``effective_point_pixel_size = max(1, pixelSize + projectedSizeOf(metricSize + tolerance * toleranceFactor))``.
        * Metric size is projected as a 3D sphere at the point origo to deterine pixel size.
        * The term pixel refers to the size of a pixel in the target canvas element, which resolution may differ from that of the render buffer.
        * @category Render State
        */
    export interface RenderStatePointCloud {
            /** Point size state. */
            readonly size: {
                    /** Point size in pixels. */
                    readonly pixel: number | undefined;
                    /** Max point size in pixels. */
                    readonly maxPixel: number | undefined;
                    /** Point size in meters. */
                    readonly metric: number | undefined;
                    /** The scaling factor for applying the tolerance of the current level of detail to point size.
                        * @remarks
                        * Different levels of detail (LOD) will have different point densities.
                        * Taking this difference into account may result in a more uniform point coverage and visually pleasing result.
                        * The tolerance of each LOD reflects the point merging distance threshold in meters used to reduce # points, or 0 for the original level of detail.
                        */
                    readonly toleranceFactor: number;
            };
            /** Point deviation state.
                * @remarks
                * Deviation is pre-computed for some point clouds as a signed, linear distance from the point to some reference/baseline geometry.
                * This is useful to visualize as-built deviances, e.g. in tunnel projects, and whether they are within tolerance and not.
                * Several channels of deviation may be computed.
                *
                * This state will not have any effect on geometry that does not have pre-computed deviance data baked into it.
                */
            readonly deviation: {
                    /** Index of deviation channel (0-3).
                        * @remarks
                        * This index specifies which deviation channel to currently render on screen and into pick buffers.
                        */
                    readonly index: number;
                    /** Mix factor [0.0, 1.0], where 0 is 100% original vertex color and 1 is 100% color gradient color */
                    readonly mixFactor: number;
                    /** Color gradient to use for visualizing deviation and tolerances.
                        * @remarks May define different gradients for negative and positive numbers.
                        */
                    readonly colorGradient: RenderStateColorGradient<RGBA>;
            };
            /** Use pre-computed projected point cloud positions instead of original.
                * @remarks This is currently used to render an unwrapped 2D variant of tunnels.
                */
            readonly useProjectedPosition: boolean;
    }
    /** How to combine the half-spaces of multiple clipping planes into a clipping volume.
        * @category Render State
        */
    export enum ClippingMode {
            /** Use the intersection of the clipping plane half-spaces.
                * @remarks
                * This is useful for creating a clipping space where everything outside e.g. a slab or a box is clipped/hidden.
                *
                * `inside_volume = inside(plane0) AND inside(plane1) AND ...`
                */
            intersection = 0,
            /** Use the union of the clipping plane half-spaces.
                * @remarks
                * This is useful for creating spaces where everything inside e.g. a slab or a box is clipped/hidden.
                *
                * `inside_volume = inside(plane0) OR inside(plane1) OR ...`
                */
            union = 1
    }
    /** Object id/indices for picking of rendered clipping planes.
        * @category Render State
        */
    export enum ClippingId {
            plane0 = 4294967280,
            plane1 = 4294967281,
            plane2 = 4294967282,
            plane3 = 4294967283,
            plane4 = 4294967284,
            plane5 = 4294967285,
            plane6 = 4294967286
    }
    /** Render state for a single clipping plane.
        * @category Render State
        */
    export interface RenderStateClippingPlane {
            /** The half-space normal (xyz) and signed offset/distance (w) of the plane. */
            readonly normalOffset: ReadonlyVec4;
            /** The color to use when visualizing the clipping plane, or undefined to not visualize. */
            readonly color?: RGBA;
            /** Geometry outline settings for this clipping plane. */
            readonly outline?: {
                    /** Whether to render outlines or not.
                        * @remarks
                        * Currently, due to limitations in WebGL2,
                        * outlines are a costly features that is disabled on weaker devices.
                        * Even on more powerful GPUs this feature should be used sparingly.
                        */
                    enabled: boolean;
                    /**
                        * The color to use for the outlines of this plane, or undefined to use the {@link RenderStateOutlines.color | default outline color}.
                        */
                    color?: RGB;
            };
    }
    /** Clipping related render state.
        * @category Render State
        */
    export interface RenderStateClipping {
            /** Whether to enable or disable geometry clipping.
                * @remarks
                * Clipping only applies to static/streamble geometry.
                * Enabling clipping comes at a minor cost of rendering performance.
                */
            readonly enabled: boolean;
            /**
                * Whether or not to visualize the clipping planes themselves.
                */
            readonly draw: boolean;
            /** How to combine multiple clipping planes. */
            readonly mode: ClippingMode;
            /** An array of up to 6 clipping planes. */
            readonly planes: readonly RenderStateClippingPlane[];
    }
    /** 5x4 row-major matrix for color/opacity transform.
        * @remarks
        * This matrix defines the linear transformation that is applied to the original RGBA color before rendering.
        * The fifth column is multiplied by a constant 1, making it useful for translation.
        * The resulting colors are computed thus:
        * ```
        * output_red = r*m[0] + g*m[1] + b*m[2] + a*m[3] + m[4]
        * output_green = r*m[5] + g*m[6] + b*m[7] + a*m[8] + m[9]
        * output_blue = r*m[10] + g*m[11] + b*m[12] + a*m[13] + m[14]
        * output_alpha = r*m[15] + g*m[16] + b*m[17] + a*m[18] + m[19]
        * ```
        * All input values are between 0 and 1 and output value will be clamped to this range.
        * @category Render State
        */
    export type RGBATransform = FixedSizeArray<20, number>;
    /**
        * How to render the geometry of a {@link RenderStateHighlightGroup | highlight group}.
        * @remarks
        * {@link RGBATransform | Color transforms} allows you to modify the color, brightness and transparency of objects within the group.
        *
        * `"hide"` will hide the objects within the group more effectively than using alpha/opacity = 0,
        *  while still retaining them in memory for quick re-rendering.
        *
        * `"filter"` will remove the objects from memory entirely, which helps improve rendering performance and memory usage.
        * Unlike hidden group, changes to filtered groups will trigger a complete reload of the streamable scene.
        * @category Render State
        */
    export type RenderStateGroupAction = RGBATransform | "hide" | "filter";
    /**
        * Render state for a specific highlight group.
        * @remarks
        * Group of objects may be visually highlighted through {@link RGBATransform | color transforms}, hidden or filtered out.
        * @category Render State
        */
    export interface RenderStateHighlightGroup {
            /** How to treat this particular group. */
            readonly action: RenderStateGroupAction;
            /** A set of unique object_id belonging to this group, sorted in ascending order. */
            readonly objectIds: Iterable<number>;
    }
    /**
        * Highlight related render state.
        * @remarks
        * Highlight comes as a modest performance cost.
        *
        * Group of objects may be visually highlighted through {@link RGBATransform | color transforms}, hidden or filtered out.
        * Currently, a maximum of 250 groups may be defined.
        * Any objects that are not part of a highlight group will be treated according to the {@link defaultAction} property.
        * This could help save memory when "everything else" needs to be hidden or highlighted.
        *
        * A particular object can only be rendered using a single highlight.
        * If the object id belongs to multiple groups, the last group in the {@link groups} array will determine how it's highlighted.
        *
        * Hiding a group is more effective than using alpha=0.
        *
        * Filtering of large group can greatly improve performance and memory consumption.
        * Adding or removing objects to filtered groups will trigger a complete reload of the scene, however.
        * It it thus recommended that this be used for relatively static groups only.
        * @category Render State
        */
    export interface RenderStateHighlightGroups {
            /** Highlight action for all objects current not in a highlight group.
                * @defaultValue `undefined`
                */
            readonly defaultAction: RenderStateGroupAction | undefined;
            /** Highlight groups, max 250. */
            readonly groups: readonly RenderStateHighlightGroup[];
    }
    /** Used to visualize internal render buffers.
        * @defaultValue `TonemappingMode.color`.
        * @category Render State
        */
    export enum TonemappingMode {
            /** Render the regular color output using HDR tone-mapping. */
            color = 0,
            /** Visualize the normal buffer. */
            normal = 1,
            /** Visualize the normal buffer. */
            depth = 2,
            /** Visualize the object id/index buffer. */
            objectId = 3,
            /** Visualize the deviation buffer, if any. */
            deviation = 4,
            /** Visualize the z-buffer. */
            zbuffer = 5
    }
    /** Outline related render state.
        * @remarks
        * Enabling this feature will render the intersection of geometry surface with the specified plane as lines.
        * This is particularly useful when in orthographic mode on surfaces that are perfectly perpendicular to the image plane.
        * These surfaces would otherwise be invisible and unpickable.
        *
        * > Due to limitations of WebGL2, outline rendering comes as at potentially significant performance and memory cost.
        * Thus, is may be unavailable on weaker devices and should be used sparingly otherwise.
        * @category Render State
        */
    export interface RenderStateOutlines {
            /** Whether to do outline rendering. */
            readonly enabled: boolean;
            /** Color of outline.
                * @remarks
                * Due to {@link RenderStateTonemapping | tone mapping} the color displayed on screen will a bit duller.
                * If you require bright colors, you may "overexpose" them, e.g. `[10,0,0]` for bright red.
                */
            readonly color: RGB;
            /** The outline intersection plane. */
            readonly plane: ReadonlyVec4;
    }
    /** Tone mapping related render state.
        * @remarks
        * Internally, the output image is rendered in a {@link https://en.wikipedia.org/wiki/High_dynamic_range | HDRI} format.
        * Before it can be displayed onto a regular screen,
        * it needs to be {@link https://en.wikipedia.org/wiki/Tone_mapping tone mapped} and truncated into a displayable format.
        * Currently we use {@link https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl | ACES filmic tone map approximation} for this.
        * @category Render State
        */
    export interface RenderStateTonemapping {
            /** Camera light exposure as stops of power of 2.
                * @remarks
                * Negative values darkens the image, while positive ones brightens it.
                * @defaultValue 0.0
                */
            readonly exposure: number;
            /** Debug/diagnostics option to display internal render buffers.
                * @defaultValue TonemappingMode.color
                */
            readonly mode: TonemappingMode;
    }
    /** Toon shader related outline.
        * @remarks
        * Toon shader is a deliberate misnomer of what is commonly referred to as {@link https://roystan.net/articles/outline-shader/ outline shader}.
        * It is a post-effect that is applied on the output pixels to help visualize geometric edges and contours.
        * Enabling it comes at a potentially significant performance penalty, depending on your device.
        * It should thus be used sparingly, preferably only on idle frames, i.e. while the camera is not moving.
        * @category Render State
        */
    export interface RenderStateToonOutline {
            /**
                * @ignore
                * @privateRemarks Ability to turn the "toon" outlines on and off based on conditions in the render loop.
                * Will be overwritten every frame
             */
            readonly on: boolean;
            /** Whether to do render "toon" outlines or not. */
            readonly enabled: boolean;
            /** Color to use for edges and contours. */
            readonly color: RGB;
    }
    /** Pick related render state.
        * @category Render State
        */
    export interface RenderStatePick {
            /** The opacity/alpha minimum (inclusive) threshold at which to include a pixel in the pick output.
                * @public
                * @remarks
                * A value between 0 and 1, where 0 includes all pixels no matter how transparent and 1 only includes 100% opaque pixels.
                * The default value is 1.
                */
            readonly opacityThreshold: number;
    }
}

declare module '@novorender/api/core3d/context' {
    import type { RenderModule, DerivedRenderState, RenderState, Core3DImports } from "@novorender/api/core3d";
    import type { UniformsProxy, TextureParamsCubeUncompressedMipMapped, TextureParamsCubeUncompressed, ShaderHeaderParams } from "@novorender/api/webgl2";
    import { RenderBuffers } from "@novorender/api/core3d/buffers";
    import type { WasmInstance } from "@novorender/api/core3d/wasm";
    import type { ReadonlyVec3 } from "gl-matrix";
    import { ResourceBin } from "@novorender/api/core3d/resource";
    import type { DeviceProfile } from "@novorender/api/core3d/device";
    /** The view specific context for rendering and picking.
        * @remarks
        * A render context describes a view into which a {@link RenderState} can be rendered.
        * It is tightly bound to a HTML canvas and WebGL2RenderingContext.
        * Consequently, it will be disposed if the gl context is lost and recreated when the gl context is restored.
        *
        * The render context must be {@link init | initialized} with an array of {@link RenderModule | render modules}.
        * Unused modules may be removed and custom ones inserted here.
        * Ordering the modules correctly is important as they are rendered in order.
        * The {@link TonemapModule} should be last, as it will copy the HDR render buffers into the output canvas to make things visible.
        *
        * Features such as async picking and shader linking requires {@link poll} to be called at regular intervals,
        * e.g. at the start of each frame.
        * Otherwise the promises will never be resolved.
        *
        * @category Render Module
        */
    export class RenderContext {
            /** The device profile use for this context. */
            readonly deviceProfile: DeviceProfile;
            /** The HTML canvas used for this context. */
            readonly canvas: HTMLCanvasElement;
            /** Imported resources. */
            readonly imports: Core3DImports;
            /** WebGL2 render context associated with this object. */
            readonly gl: WebGL2RenderingContext;
            /** WebGL common GLSL code header used across shaders. */
            readonly commonChunk: string;
            /** WebGL basic fallback IBL textures to use while loading proper IBL textures. */
            readonly defaultIBLTextureParams: TextureParamsCubeUncompressed;
            /** Web assembly instance. */
            readonly wasm: WasmInstance;
            /** WebGL uniform buffer for camera related uniforms. */
            readonly cameraUniforms: WebGLBuffer;
            /** WebGL uniform buffer for clipping related uniforms. */
            readonly clippingUniforms: WebGLBuffer;
            /** WebGL uniform buffer for outline related uniforms. */
            readonly outlineUniforms: WebGLBuffer;
            /** WebGL GGX/PBR shading lookup table texture. */
            readonly lut_ggx: WebGLTexture;
            /** WebGL Sampler used to sample mipmapped diffuse IBL texture. */
            readonly samplerMip: WebGLSampler;
            /** WebGL Sampler used to sample other, non-mipmapped IBL textures. */
            readonly samplerSingle: WebGLSampler;
            /** {@link RenderState} used to render the previous frame, if any. */
            prevState: DerivedRenderState | undefined;
            /** Set to true to force a re-render when state not contained in {@link RenderState} has changed, e.g. download complete etc. */
            changed: boolean;
            /** WebGL render and pick buffers
                * @remarks
                * Note that these buffers will be recreated whenever the {@link RenderState.output} size changes.
                */
            buffers: RenderBuffers;
            /** WebGL textures used for image based lighting ({@link https://en.wikipedia.org/wiki/Image-based_lighting | IBL}).
                * @remarks
                * Note that these buffers will be changed by the background module when download of the specified {@link RenderState.background.url} IBL textures completes.
                *
                * The process to create the textures are similar to that of {@link https://github.com/KhronosGroup/glTF-IBL-Sampler}/
                */
            iblTextures: {
                    /** WebGL cubemap texture containing the irradiance/diffuse values of current IBL environment. */
                    readonly diffuse: WebGLTexture;
                    /** WebGL cubemap texture containing the radiance/specular values of current IBL environment. */
                    readonly specular: WebGLTexture;
                    /** # mip maps in current specular texture. */
                    readonly numMipMaps: number;
                    /** # True if these are the default IBL textures. */
                    readonly default: boolean;
            };
            /** Initialize render context with specified render modules.
                * @remarks
                * The default/built-in render modules can be retrieved using {@link createDefaultModules}.
                * These will be used if no modules are specified.
                * Developers may introduce their own render modules here.
                * Note that the order of the modules matters, as this is the order by which they will be rendered.
                */
            init(modules?: readonly RenderModule[]): Promise<void>;
            /**
                * Dispose of the GPU resources used by this context, effectively destroying it and freeing up memory.
                * @remarks
                * Calling this method is optional as the garbage collection of the underlying WebGL render context will do the same thing.
                * This may take some time, however, so calling this function is recommended if you plan to create a new context shortly thereafter.
                */
            dispose(): void;
            /** Return the current pixel width of the drawing buffer. */
            get width(): number;
            /** Return the current pixel height of the drawing buffer. */
            get height(): number;
            /** Query if pick buffers are valid.
                * @remarks This could be useful for optimistic/non-async picking.
                */
            isPickBuffersValid(): boolean;
            /** Query whether the underlying WebGL render context is currently lost.
                * @remarks
                * This could occur when too many resources are allocated or when browser window is dragged across screens.
                * Loss and restoration of WebGL contexts is supported by this API automatically.
                */
            isContextLost(): boolean;
            /** Helper function to update WebGL uniform buffer from proxies. */
            updateUniformBuffer(uniformBuffer: WebGLBuffer, proxy: UniformsProxy): void;
            /** Explicitly update WebGL IBL textures from specified parameters. */
            updateIBLTextures(params: {
                    readonly diffuse: TextureParamsCubeUncompressed;
                    readonly specular: TextureParamsCubeUncompressedMipMapped;
            } | null): void;
            /**
                * Helper function to check for changes in render state.
                * @param state The parts of the render state to check for changes.
                * @returns True if any of the specified parts has changed since last frame.
                * @remarks
                * Since the render state is immutable, any changes will automatically trickle up to the container object as well.
                * Thus, this function does a shallow strict equality of the parts of the renderstate specified in the state parameter.
                * @example
                * Example of how to check for changes in either camera or output render state.
                * ```typescript
                * const {camera, output} = renderState;
                * if(renderContext.hasStateChanged({camera, output})) {
                *   // update related GPU state here...
                * }
                * ```
                */
            hasStateChanged(state: Partial<DerivedRenderState>): boolean;
            /** Create a new named resource bin. */
            resourceBin(name: string): ResourceBin;
            /** Compile WebGL/GLSL shader program asynchronously. */
            makeProgramAsync(resourceBin: ResourceBin, params: AsyncProgramParams): Promise<WebGLProgram>;
            /** Poll the status of WebGL pick fences and timers and resolve associated promises when possible. */
            poll(): void;
            /** Wait for the next frame to be ready for rendering.
                * @param context render context to wait for, if any.
                * @remarks Use this function instead of requestAnimationFrame()!
                */
            static nextFrame(context: RenderContext | undefined): Promise<number>;
            /**
                * Render a new frame using the specified render state.
                * @param state An object describing what the frame should look like.
                * @returns A promise to the performance related statistics involved in rendering this frame.
                */
            render(state: RenderState): Promise<RenderStatistics>;
            /**
                * Pick information about underlying object and geometry.
                * @param x Center x coordinate in CSS pixels.
                * @param y Center y coordinate in CSS pixels.
                * @param options More details of pick operation.
                * @returns A set of pick samples of the specified sample disc.
                */
            pick(x: number, y: number, options?: PickOptions): Promise<PickSample[]>;
    }
    /**
        * Pick Sample information
        */
    export interface PickSample {
            /** relative x pixel offset (not css pixel) from pick center. */
            readonly x: number;
            /** relative y pixel offset (not css pixel) from pick center. */
            readonly y: number;
            /** World space position of underlying pixel. */
            readonly position: ReadonlyVec3;
            /** World space normal of underlying pixel. */
            readonly normal: ReadonlyVec3;
            /** The object id/index of underlying pixel. */
            readonly objectId: number;
            /** The spatial deviation of underlying pixel, if any.
                * @remarks This only applies to point clouds with precomputed deviation data.
                */
            readonly deviation?: number;
            /** The depth/distance from the view plane. */
            readonly depth: number;
    }
    /** Extra pick options. */
    export interface PickOptions {
            /** The radius of the sample disc (0 yields a single pixel). */
            readonly sampleDiscRadius?: number;
            /** True to wait for the pick buffers to be available, false to return whatever is in the current pick buffer synchronously.
                * @remarks The latter option is more error prone, but useful for e.g. mouse hover operations.
                */
            readonly async?: boolean;
            /** Return pick without depth. */
            readonly pickCameraPlane?: boolean;
    }
    /** Parameters for asynchronous shader compilation and linking. */
    export interface AsyncProgramParams {
            /** Common GLSL header information to be inserted before the body code. */
            readonly header?: Partial<ShaderHeaderParams>;
            /** The vertex shader. */
            readonly vertexShader: string;
            /** The fragment shader (optional with transform feedback shaders). */
            readonly fragmentShader?: string;
            /** The names of the vertex attributes to be bound prior to linking using gl.bindAttribLocation(). */
            readonly attributes?: readonly string[];
            /** The names of the shader uniform blocks to be bound prior to linking using gl.uniformBlockBinding(), in the order which they appear */
            readonly uniformBufferBlocks?: readonly string[];
            /** Texture uniforms to be bound post-linking. */
            readonly textureUniforms?: readonly string[];
            /** Transform feedback buffers to be bound post-linking. */
            readonly transformFeedback?: {
                    /** Should output attributes be written into a single interleaved buffer or separate buffers? */
                    readonly bufferMode: "INTERLEAVED_ATTRIBS" | "SEPARATE_ATTRIBS";
                    /** Name of output attribute names (varyings). */
                    readonly varyings: readonly string[];
            };
    }
    /** Render frame performance and resource usage statistics. */
    export interface RenderStatistics {
            /** Estimated # bytes used by WebGL buffers for this frame. */
            readonly bufferBytes: number;
            /** Estimated # bytes uses by WebGL textures for this frame. */
            readonly textureBytes: number;
            /** # of points drawn in this frame. */
            readonly points: number;
            /** # of lines drawn in this frame. */
            readonly lines: number;
            /** # of triangles drawn in this frame. */
            readonly triangles: number;
            /** # of draw calls in this frame. */
            readonly drawCalls: number;
            /** # of primitives (points+lines+triangles) drawn by static geometry for this frame. */
            readonly primitives: number;
            /** Time spent in the main thread. */
            readonly cpuTime: {
                    /** # CPU milliseconds spent rendering. */
                    readonly draw: number;
            };
            /** Time spent in the GPU. */
            readonly gpuTime: {
                    /** # GPU milliseconds spent rendering, if supported by driver. */
                    readonly draw: number | undefined;
            };
            /** Effective interval in milliseconds since last frame was drawn. */
            readonly frameInterval: number;
    }
}

declare module '@novorender/api/core3d/modules' {
    import type { DerivedRenderState } from "@novorender/api/core3d/state";
    import type { RenderContext } from "@novorender/api/core3d/context";
    /** A render module factory object.
        * @remarks
        * The render module should be able to gracefully recreate its context from a new render context whenever a lost GL context is restored.
        * @category Render Module
        */
    export interface RenderModule {
            /** Human readable name of module. */
            readonly kind: string;
            /** Create a new instance for a given render context. */
            withContext(context: RenderContext): RenderModuleContext | Promise<RenderModuleContext>;
    }
    /** A render module's context for a specific render context.
        * @remarks This object should contain all GPU/render context specific resources and handle actual updates and rendering.
        * @category Render Module
        */
    export interface RenderModuleContext {
            /** Associated render module. */
            readonly module: RenderModule;
            /**
                * Update module specific GPU state, such as uniform buffers.
                * @param state The current frame render state.
                */
            update(state: DerivedRenderState): void;
            /**
                * Do a preliminary render pass to fill in Z-buffer for GPUs where this is beneficial.
                * @param state The current frame render state.
                */
            readonly prepass?: (state: DerivedRenderState) => void;
            /**
                * Render into pick buffers with module specific data.
                * @param state The current frame render state.
                */
            readonly pick?: (state: DerivedRenderState) => void;
            /**
                * Render into color and depth buffer.
                * @param state The current frame render state.
                */
            render(state: DerivedRenderState): void;
            /** Handle loss of underlying WebGLContext, e.g. by cancelling pending downloads. */
            contextLost(): void;
            /** Dispose of all GPU resources. */
            dispose(): void;
    }
}

declare module '@novorender/api/core3d/device' {
    import type { GPUTier } from "web_app/device";
    /**
        * Information about current device performance and limitations.
        * @remarks
        * This information is normally not available in the browser for security reasons.
        * Hence, we make a best guess estimate based on known device names, GPU model names, a basic benchmark test.
        * Overestimating may crash the browser, so when in doubt we go with a low estimate.
        * Underestimating will produce fewer details and lower resolution/quality than your device can handle.
        * Knowledgeable users may adjust these settings manually, but should be warned to do so with caution.
        * @category Device Profile
     */
    export interface DeviceProfile {
            /** What features should be enabled or disabled on this device. */
            readonly features: DeviceFeatures;
            /** What are the practical resource limitations of this device.
                * @remarks
                * Note these are also limited by the browser and other resources currently in use.
                */
            readonly limits: DeviceLimits;
            /** What particular quirks/bugs does this device have.
                * @remarks
                * Note these are also limited by the browser and other resources currently in use.
                */
            readonly quirks: DeviceQuirks;
            /** Geometry detail bias.
                * @remarks
                * A value of 1.0 is a reasonable default for mid-end devices and acts as a baseline.
                * Smaller values will produce less geometric details, which may improve rendering performance at the cost of geometric error.
                * Larger values will produce more geometric details, which in turn requires more powerful GPU to keep performance acceptable.
                * The formula is essentially this:
                * `acceptable_geometric_error = geometry_max_error / detailBias`
                */
            readonly detailBias: number;
            /** Render resolution bias.
                * @remarks
                * A value of 1.0 is a reasonable default for mid-end devices and acts as a baseline.
                * Smaller values will reduce resolution, which may improve rendering performance at the cost of less image fidelity.
                * Larger values will increase more details, which in turn requires more powerful GPU to keep performance acceptable.
                * The formula is essentially this:
                * `effective_resolution = default_resolution * renderResolution`
                */
            readonly renderResolution: number;
            /** Target framerate to aim for on this device.
                * @remarks
                * Most devices can display up to 60 FPS, which is perceived as nice and fluid.
                * However, lower frame rates enables more detail and fidelity.
                * 30 or even 20 frames per second may be acceptable on weak devices.
                * Note that this value is merely a hint for automatic adjustments and does not guarantee the effective framerate.
                */
            readonly framerateTarget: number;
            /** General GPU tier for this device.
                * @remarks
                * 0 is weakest, while higher tiers represent more powerful GPUs.
                * The tier system is a gross simplification of GPU performance estimation and does not allow for device specific fine tuning.
                * Use as a starting point only.
                */
            readonly tier: GPUTier;
    }
    /** Feature flags for current device. True = enable.
        * @category Device Profile
        */
    export interface DeviceFeatures {
            /** Enable/disable outline rendering. */
            readonly outline: boolean;
    }
    /** Device hardware limitations.
        * @remarks
        * Note that these limitations should reflect the effective limitations of the browser hosting web app, with room for UI and other app related resources.
        * @category Device Profile
        */
    export interface DeviceLimits {
            /** Max. # bytes allowed for GPU resources, such as buffers and textures. */
            readonly maxGPUBytes: number;
            /** Max. render primitives (points, lines and triangles) allowed for each frame. */
            readonly maxPrimitives: number;
            /** Max. # of multisample anti aliasing {@link https://en.wikipedia.org/wiki/Multisample_anti-aliasing | MSAA}.
                * @remarks
                * Should be an integer number, generally between 2 and 16.
                * Higher numbers will give better anti aliasing at the expense of slower rendering and more memory usage.
                * 4 is a reasonable value for most devices.
                * 8 works well on powerful discrete GPUs, such as Nvidia.
                * If this value exceeds the max # samples allowed on this device, the driver will cap it to the lower number.
                */
            readonly maxSamples: number;
    }
    /** Known device specific quirks and bugs that we can work around.
        * @remarks
        * These problems usually stems from buggy native WebGL drivers.
        * Workarounds may involve disabling certain features or not producing certain outputs.
        * @category Device Profile
        */
    export interface DeviceQuirks {
            /** Adreno 600 series driver bug. Normals in the picking buffer will be 0 and toon shading will be off. */
            readonly adreno600: boolean;
            /** Older Android webgl drivers struggle to compile large shader programs, even asynchronously. To avoid stuttering, disable aggressive recompile, at the expense of overall render performance. */
            readonly slowShaderRecompile: boolean;
    }
}

declare module '@novorender/api/core3d/imports' {
    import type { WasmInstance } from "@novorender/api/core3d";
    import type { ShaderImports } from "core3d/shaders";
    import type { TextureImageSource } from "@novorender/api/webgl2";
    /**
        *  Core3D bundler/build resource imports.
        * @remarks
        * In order to adapt to any build/bundler system and inlining preferences, we declare all non-javascript imported resources here.
        * These must be created by some external function that is specific to your build/bundler environment.
        * @category Render View
        */
    export interface Core3DImports {
            /** The GGX shader lookup image.
                * @remarks This image can be found in `core3d/lut_ggx.png`.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CreateImageBitmap | createImageBitmap}
                */
            readonly lutGGX: TextureImageSource;
            /** The web assembly instance.
                * @remarks This web assembly can be found in `core3d/wasm/main.wasm`.
                * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running | Loading and running WebAssembly code}
                */
            readonly wasmInstance: WasmInstance;
            /** The scene load/parse worker.
                * @remarks This worker root can be found in `core3d/modules/octree/worker/index.ts`.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker | Worker: Worker() constructor}
                */
            readonly loaderWorker: Worker;
            /** The watermark logo data.
                * @remarks This file can be found in `core3d/modules/watermark/logo.bin`.
                */
            readonly logo: ArrayBuffer;
            /** GLSL shader imports.
                * @remarks The shaders can be found in `core3d/imports/shaders.ts`.
                */
            readonly shaders: ShaderImports;
    }
    /**
        * A map describing inlined resources, or urls where to fetch them.
        */
    export interface Core3DImportMap {
            /** The base url to be applied to the other URLs.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL}
                * @defaultValue `import.meta.url`
                */
            readonly baseUrl?: string | URL;
            /** Inlined GGX lookup texture as Blob or ImageBitmap, or URL to download.
                * @defaultValue `"./lut_ggx.png"`
                * @remarks Blobs should have their type set to the proper MIME type, e.g. `type: "image/png"`.
                */
            readonly lutGGX?: string | URL | Blob | ImageBitmap;
            /** Inlined WASM instance, or URL to download.
                * @defaultValue `"./main.wasm"`
                */
            readonly wasmInstance?: string | URL | WasmInstance;
            /** Inlined loader worker, or URL to download.
                * @defaultValue `"./loaderWorker.js"`
                */
            readonly loaderWorker?: string | URL | Worker;
            /** Inlined Logo, or URL to download.
                * @defaultValue `"./logo.bin"`
                */
            readonly logo?: string | URL | ArrayBuffer;
            /** Inlined shaders, or URL to download.
                * @defaultValue `"./shaders.js"`
                */
            readonly shaders?: string | URL | ShaderImports;
    }
    /** Download any missing imports.
        * @param map URLs or bundled asset map.
        * @remarks
        * This function will attempt to download any resource not inlined from the specified urls,
        * using the specified {@link Core3DImportMap.baseUrl | baseUrl}.
        * If map is undefined, it will look for the files in the same folder as the current script.
        *
        * @category Render View
        */
    export function downloadImports(map: Core3DImportMap): Promise<Core3DImports>;
}

declare module '@novorender/api/core3d/benchmark' {
    export * from "@novorender/api/core3d/benchmark/benchmark";
    export * from "@novorender/api/core3d/benchmark/fillrate";
    export * from "@novorender/api/core3d/benchmark/pointrate";
}

declare module '@novorender/api/core3d/wasm' {
    import { type Float16Instance } from "@novorender/api/core3d/wasm/float16";
    /** The web assembly instance used by the render context. */
    export interface WasmInstance extends Float16Instance {
    }
}

declare module '@novorender/api/core3d/scene' {
    import type { RenderStateScene } from "@novorender/api/core3d";
    /**
      * Download scene from url.
      * @param url Url of scene Root folder, e.g. `https://blobs.novorender.com/<sceneid>/`
      * @param abortController Optional abort controller.
      * @returns A render state scene ready to be assign to {@link RenderState.scene}.
      * @remarks
      * The loaded state does not contain any geometry, only the data required to start geometry streaming.
      * It may take several frames for any geometry to appear, and several seconds for it to fully resolve.
      * @category Render State
      */
    export function downloadScene(url: string, abortController?: AbortController): Promise<RenderStateScene>;
}

declare module '@novorender/api/core3d/gltf' {
    /**
      * Load a {@link https://www.khronos.org/gltf/ | gltf} file from url.
      * @param url Url to gltf or glb file.
      * @param baseObjectId The base (start) object id to assign to the loaded object for picking.
      * @param abortController Optional abort controller.
      * @returns An array of dynamic render state objects ready to be assigned to {@link RenderState.dynamic}.
      * @remarks
      * Only a subset of the features in {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html | glTF2} specs are supported.
      * More specifically, unsupported features are:
      *
      * {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-accessor-sparse | Sparse accessors}
      *
      * {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-animation | Animation}
      *
      * {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-camera | Camera}
      *
      * {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-skin | Skin}
      *
      * Currently the only extensions supported is {@link https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md | KHR_materials_unlit}.
      * @category Geometry
      */
    export function downloadGLTF(url: URL, baseObjectId?: number, abortController?: AbortController): Promise<readonly import("../").RenderStateDynamicObject[]>;
}

declare module '@novorender/api/web_app/controller/builtin' {
    import type { PickContext } from "@novorender/api/web_app/controller/base";
    import { FlightController, CadMiddlePanController, CadRightPanController, SpecialFlightController } from "@novorender/api/web_app/controller/flight";
    import type { ControllerInput } from "@novorender/api/web_app/controller/input";
    import { NullController } from "@novorender/api/web_app/controller/null";
    import { OrbitController } from "@novorender/api/web_app/controller/orbit";
    import { OrthoController } from "@novorender/api/web_app/controller/ortho";
    import { PanoramaController } from "@novorender/api/web_app/controller/panorama";
    /**
        * Return the built-in camera controllers.
        * @param input The control input.
        * @param pick The control pick context, typically the view in where
        */
    export function builtinControllers(input: ControllerInput, pick: PickContext): {
            readonly orbit: OrbitController;
            readonly flight: FlightController;
            readonly ortho: OrthoController;
            readonly panorama: PanoramaController;
            readonly cadMiddlePan: CadMiddlePanController;
            readonly cadRightPan: CadRightPanController;
            readonly special: SpecialFlightController;
            readonly null: NullController;
    };
    /** Types of built-in camera controller.
        * @category Camera Controller
        * @category Render View
        */
    export type BuiltinCameraControllerType = ReturnType<typeof builtinControllers>;
    /** Kind strings of built-in camera controller.
        * @category Camera Controller
        * @category Render View
        */
    export type BuiltinCameraControllerKind = keyof BuiltinCameraControllerType;
}

declare module '@novorender/api/web_app/controller/input' {
    /**
        * The input source of camera controllers.
        * @remarks
        * This class abstract away input gestures, such as mouse, keyboard and touch event into a unified model.
        * It does this by defining a {@link ControllerAxes | set of axes} that represents an imagined gamepad/joystick input device for each class of input gestures.
        * The assumption is that each of these axes may be bound to a pair of keyboard keys, e.g. `A` and `D`, or some input position coordinate, e.g. the mouse `x` position for left/right motion.
        * All of these axes are updated independently, i.e. it is possible to move a camera with both keyboard and mouse simultaneously.
        * It is up to each camera controller to scale and apply each of these axes into an actual motion of the camera.
        * @category Camera Controllers
        */
    export class ControllerInput {
            /** The underlying HTMLElement providing input events. */
            readonly domElement: HTMLElement;
            /** A set of optional callbacks for controllers that wants to handle certain input events themselves. */
            callbacks: ContollerInputContext | undefined;
            /** The current values of each input axis. */
            readonly axes: ControllerAxes;
            /** The current list of individual touch contact points. */
            touchPoints: readonly TouchContactPoint[];
            /** Whether to use {@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API | mouse pointer lock} or not. */
            usePointerLock: boolean;
            /**
                * @param domElement The HTMLElement to subscribe to input events from.
                */
            constructor(domElement?: HTMLElement);
            /** Unsubscribe from input events. */
            dispose(): void;
            /** Return the client width of the input {@link domElement}. */
            get width(): number;
            /** Return the client height of the input {@link domElement}. */
            get height(): number;
            /** Current multiplier applied to motion via the Control/Alt keys. */
            get multiplier(): number;
            /** Whether the shift key is currently pressed or not. */
            get hasShift(): boolean;
            /** The pixel position centering zoom gestures.
                * @remarks
                * This is typically the current cursor position while using the mouse scroll wheel,
                * or the center position between touch points in a pinch gesture.
                */
            get zoomPos(): number[];
            /** Subscribe to input events from {@link domElement}. */
            protected connect(): void;
            /** Unsubscribe to input events from {@link domElement}. */
            protected disconnect(): void;
            /** Indicate whether the mouse scroll wheel has recently been moved. */
            isScrolling(): boolean;
            /** Apply time-related state updates.
                * @param elapsedTime The amount of milliseconds passed since the last call to this function.
                */
            animate(elapsedTime: number): void;
            /** Reset axes to their default/neutral state. */
            resetAxes(): void;
            /** Determine if axes are all at their default/neutral state. */
            axesEmpty(): boolean;
    }
    /** Flags for various mouse buttons.
        * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons}
        * @category Camera Controllers
        */
    export enum MouseButtons {
            none = 0,
            left = 1,
            right = 2,
            middle = 4,
            backward = 8,
            forward = 16
    }
    type ControllerAxesName = "keyboard_ad" | "keyboard_ws" | "keyboard_qe" | "keyboard_arrow_left_right" | "keyboard_arrow_up_down" | "mouse_lmb_move_x" | "mouse_lmb_move_y" | "mouse_rmb_move_x" | "mouse_rmb_move_y" | "mouse_mmb_move_x" | "mouse_mmb_move_y" | "mouse_navigate" | "mouse_navigate" | "mouse_wheel" | "touch_1_move_x" | "touch_1_move_y" | "touch_2_move_x" | "touch_2_move_y" | "touch_3_move_x" | "touch_3_move_y" | "touch_pinch2" | "touch_pinch3";
    /** The input gesture axes values.
        * @property keyboard_ad Keyboard `A` and `D` axis.
        * @property keyboard_ws Keyboard `W` and `S` axis.
        * @property keyboard_qe Keyboard `Q` and `E` axis.
        * @property keyboard_arrow_left_right Keyboard cursor left and right axis.
        * @property keyboard_arrow_up_down Keyboard cursor up and down axis.
        * @category Camera Controllers
        */
    export type ControllerAxes = {
            [P in ControllerAxesName]: number;
    };
    /** Input event callbacks.
        * @category Camera Controllers
        */
    export interface ContollerInputContext {
            /** Mouse button events. */
            mouseButtonChanged(event: MouseEvent): Promise<void> | void;
            /** Touch "click" events. */
            touchChanged(event: TouchEvent): Promise<void> | void;
            /** Mouse or touch move events. */
            moveBegin(event: TouchEvent | MouseEvent): Promise<void> | void;
    }
    /** A single touch input contact point.
        * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} for more details.
        * @category Camera Controllers
        */
    export interface TouchContactPoint {
            /** The touch identifier.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch/identifier}
                */
            readonly id: number;
            /** The touch client x coordinate.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch/clientX}
                */
            readonly x: number;
            /** The touch client y coordinate.
                * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch/clientY}
                */
            readonly y: number;
    }
    export {};
}

declare module '@novorender/api/web_app/controller/base' {
    import { type ReadonlyVec3, type ReadonlyQuat } from "gl-matrix";
    import type { RenderStateCamera, RenderStateChanges, BoundingSphere, PickSample, PickOptions } from "@novorender/api/core3d";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    import type { FlightControllerParams } from "@novorender/api/web_app/controller/flight";
    import type { OrbitControllerParams } from "@novorender/api/web_app/controller/orbit";
    import type { OrthoControllerParams } from "@novorender/api/web_app/controller/ortho";
    import type { PanoramaControllerParams } from "@novorender/api/web_app/controller/panorama";
    /** Base class for all camera controllers.
        * @category Camera Controllers
        */
    export abstract class BaseController {
            /** The input source for this controller. */
            readonly input: ControllerInput;
            /** The controller type id. */
            abstract readonly kind: string;
            /** The camera projection kind.
                * @see {@link RenderStateCamera.kind}.
                */
            abstract readonly projection: RenderStateCamera["kind"] | undefined;
            /**
                * Camera controller state generation.
                * @remarks
                * If the controller state changes, the generation count will be incremented once every call to {@link renderStateChanges}.
                * This can be used to detect changes by comparing to a local generation count.
                * The count is wrapped at 0xffffffff, so make sure you use != comparison and not < comparison.
                */
            get generation(): number;
            /** Signal changes to internal state. */
            protected changed(): void;
            /**
                * @param input The input source for this controller.
                */
            protected constructor(
            /** The input source for this controller. */
            input: ControllerInput);
            /** The input axes
                * @see {@link ControllerInput.axes}
                */
            get axes(): import("./input").ControllerAxes;
            /** Whether the camera is currently considered moving or not.
                * @see {@link View.isIdleFrame}
                */
            get moving(): boolean;
            /** The input element width.
                * @see {@link ControllerInput.width}
                */
            get width(): number;
            /** The input element height.
                * @see {@link ControllerInput.height}
                */
            get height(): number;
            /** The input multiplier.
                * @see {@link ControllerInput.multiplier}
                */
            get multiplier(): number;
            /** The input zoom position.
                * @see {@link ControllerInput.zoomPos}
                */
            get zoomPos(): number[];
            /** The input pointer table.
                * @see {@link ControllerInput.touchPoints}
                */
            get pointerTable(): readonly import("./input").TouchContactPoint[];
            /** The input shift button state.
                * @see {@link ControllerInput.hasShift}
                */
            get hasShift(): boolean;
            /** The current fly-to state, if any. */
            get currentFlyTo(): Orientation | undefined;
            /** Initialize a fly-to transition.
                * @param flyTo The transition parameters
                */
            protected setFlyTo(flyTo: FlyToParams): void;
            /** Apply time sensitive changes to controller state.
                * @param elapsedTime The # of milliseconds elapsed since the last update.
                * @remarks
                * Fly-to animations happens here,
                * as well as motion based on keyboard pressed-state, such as the WASD keys.
                */
            animate(elapsedTime: number): void;
            /** Serialize the state of this controller into init parameters.
                * @param includeDerived Include derived state which may not be intrinsic to this controller, such as orbit controller position.
                * @see {@link init}
                */
            abstract serialize(includeDerived?: boolean): ControllerInitParams;
            /** Initialize controller from parameters.
                * @see {@link serialize}
                */
            abstract init(params: ControllerInitParams): void;
            /** Attempt to fit controller position such that the specified bounding sphere is brought into view.
                * @param center The center of the bounding sphere, in world space.
                * @param radius The radius of the bounding sphere, in world space.
                */
            abstract autoFit(center: ReadonlyVec3, radius: number): void;
            /** Update internal controller state */
            abstract update(): void;
            /** Retrieve changes to render state from derived class, if any.
                * @param state The baseline state to apply changes to.
                * @see {@link View.modifyRenderState}
                * @remarks
                * If there are no changes, the returned object will be empty, i.e. {}.
                */
            abstract stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            /** Attach this controller to the input object */
            attach(): void;
            /**
                * Handler for mouse buttons events.
                * @virtual
                */
            mouseButtonChanged(event: MouseEvent): Promise<void> | void;
            /**
                * Handler for touch events.
                * @virtual
                */
            touchChanged(event: TouchEvent): Promise<void> | void;
            /**
                * Handler for mouse/touch move events.
                * @virtual
                */
            moveBegin(event: TouchEvent | MouseEvent): Promise<void> | void;
            /** Move controller to specified position/rotation.
                * @param targetPosition: The position to move to, in world space.
                * @param flyTime: The time, in milliseconds, for the transition animation to last, or 0 for instant update.
                * @param rotation: Optional target rotation, or undefined to retain current rotation.
                * @virtual
                */
            moveTo(targetPosition: ReadonlyVec3, flyTime?: number, rotation?: ReadonlyQuat): void;
            /** Bring the specified bounding sphere into view.
                * @param boundingSphere: The bounding sphere to move into view.
                * @param flyTime: The time, in milliseconds, for the transition animation to last, or 0 for instant update.
                * @virtual
                * @remarks
                * This function will retain the current camera controller rotation.
                */
            zoomTo(boundingSphere: BoundingSphere, flyTime?: number): void;
            /** Retrieve the state changes to be applied to the specified render state.
                * @param state The baseline render state.
                * @param elapsedTime The time elapsed since last call, in milliseconds.
                */
            renderStateChanges(state: RenderStateCamera, elapsedTime: number): RenderStateChanges | undefined;
            /** Compute the distance to a point from the specified view plane.
                * @param point The point to measure distance too
                * @param cameraPosition The position of the camera/view plane.
                * @param cameraRotation The rotation of the camera/view plane.
                * @returns A signed distance from the point to the view plane, i.e. positive for points in front of the plane and negative otherwise.
                */
            protected static getDistanceFromViewPlane(point: ReadonlyVec3, cameraPosition: ReadonlyVec3, cameraRotation: ReadonlyQuat): number;
    }
    /** Common controller input parameters.
        * @category Camera Controllers
        */
    export type ControllerParams = FlightControllerParams | OrthoControllerParams | PanoramaControllerParams | OrbitControllerParams;
    /** Camera controller 3D orientation in world space.
        * @category Camera Controllers
        */
    export interface Orientation {
            /** Camera position. */
            readonly pos: ReadonlyVec3;
            /** Camera pitch angle in degrees. */
            readonly pitch: number;
            /** Camera yaw angle in degrees. */
            readonly yaw: number;
    }
    /** Camera fly-to transition/animation parameter
        * @category Camera Controllers
        */
    export interface FlyToParams {
            /** Total flight time in milliseconds. */
            readonly totalFlightTime: number;
            /** The transition start camera orientation. */
            readonly begin: Orientation;
            /** The transition end camera orientation. */
            readonly end: Orientation;
    }
    /** A context interface for pick operations.
        * @remarks
        * This is used by some controllers to determine the position and depth of point of screen to allow e.g. orbiting around said point.
        * You may pass {@link View} or {@link RenderContext} directly, or wrap some custom variant of picking in your own object.
        * @see {@link View.pick}
        * @category Camera Controllers
        */
    export interface PickContext {
            pick: (x: number, y: number, options?: PickOptions) => Promise<PickSample | undefined>;
    }
    /** Common controller initialization parameters.
        * @remarks
        * No controller uses all of these parameters.
        * This interface represents the union of all possible intialization paramters for all possible controllers.
        * This is useful for deserialization, where the kind of controller is not known at compile time.
        * @category Camera Controllers
        */
    export interface ControllerInitParams {
            /** The kind of controller to initialize. */
            readonly kind: string;
            /** The camera position, if applicable. */
            readonly position?: ReadonlyVec3;
            /** The camera rotation, if applicable. */
            readonly rotation?: ReadonlyQuat;
            /** The camera perspective field of view, in degrees, if applicable. */
            readonly fovDegrees?: number;
            /** The camera orthographic field of meters, in degrees, if applicable. */
            readonly fovMeters?: number;
            /** The camera pivot point, if applicable. */
            readonly pivot?: ReadonlyVec3;
            /** The distance to the pivot point, if applicable. */
            readonly distance?: number;
    }
}

declare module '@novorender/api/web_app/controller/orbit' {
    import { type RenderStateCamera } from "@novorender/api/core3d";
    import { type ReadonlyVec3, vec3, type ReadonlyQuat } from "gl-matrix";
    import { BaseController, type ControllerInitParams } from "@novorender/api/web_app/controller/base";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    /** A camera controller for orbiting around a point of interest.
        * @category Camera Controllers
        */
    export class OrbitController extends BaseController {
            kind: "orbit";
            projection: "pinhole";
            /**
                * @param input The input source.
                * @param params Optional initialization parameters.
                */
            constructor(input: ControllerInput, params?: Partial<OrbitControllerParams>);
            /** The current controller parameters. */
            get parameters(): OrbitControllerParams;
            /** Computed position, in world space.
                * @remarks
                * This position is derived from {@link pivot} point, {@link distance}, rotated around {@link pitch} and {@link yaw} angles.
                */
            get position(): vec3;
            /** Computed rotation quaternion, in world space.
                * @remarks
                * This rotation is derived from {@link pitch} and {@link yaw} angles.
                */
            get rotation(): ReadonlyQuat;
            /** The pitch angle around the pivot point, in degrees. */
            get pitch(): number;
            set pitch(value: number);
            /** The yaw angle around the pivot point, in degrees. */
            get yaw(): number;
            set yaw(value: number);
            /** The pivot point to orbit around, in world space. */
            get pivot(): ReadonlyVec3;
            set pivot(value: ReadonlyVec3);
            /** The distance from the pivot point, in meters. */
            get distance(): number;
            set distance(value: number);
            /** The camera vertical field of view angle, in degrees. */
            get fov(): number;
            set fov(value: number);
            /** Update controller parameters.
                * @param params Set of parameters to change.
                */
            updateParams(params: Partial<OrbitControllerParams>): void;
            serialize(includeDerived?: boolean): ControllerInitParams;
            init(params: ControllerInitParams): void;
            autoFit(center: ReadonlyVec3, radius: number): void;
            update(): void;
            stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            /** OrbitController type guard function.
                * @param controller The controller to type guard.
                */
            static is(controller: BaseController): controller is OrbitController;
            /** OrbitController type assert function.
                * @param controller The controller to type assert.
                */
            static assert(controller: BaseController): asserts controller is OrbitController;
    }
    /** Orbit type camera motion controller
        * @category Camera Controllers
        */
    export interface OrbitControllerParams {
            /** The camera distance relative to pivot point in meters. */
            readonly maxDistance: number;
            /** Linear velocity modifier (default is 1.0) */
            readonly linearVelocity: number;
            /** Rotational velocity modifier (default is 1.0) */
            readonly rotationalVelocity: number;
    }
}

declare module '@novorender/api/web_app/controller/ortho' {
    import { type ReadonlyVec3, type ReadonlyQuat } from "gl-matrix";
    import { BaseController, type ControllerInitParams } from "@novorender/api/web_app/controller/base";
    import { type BoundingSphere, type RenderStateCamera } from "@novorender/api/core3d";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    /** The ortho controller is for navigating a orthographic camera.
        * @remarks
        * A key aspect of this controller is as a means to view and navigate in 2D,
        * aligning the parallel to the view plane to the axes or some reference plane.
        * The front and back clipping planes are used to reveal a limited slab of the geometry.
        * @category Camera Controllers
        */
    export class OrthoController extends BaseController {
            kind: "ortho";
            projection: "orthographic";
            /**
                * @param input The input source.
                */
            constructor(input: ControllerInput);
            /** Camera position, in world space. */
            get position(): ReadonlyVec3;
            set position(value: ReadonlyVec3);
            /** Computed rotation quaternion, in world space.
                * @remarks
                * This rotation is derived from {@link pitch}, {@link yaw} and  {@link roll} angles.
                */
            get rotation(): ReadonlyQuat;
            /** The camera pitch angle, in degrees. */
            get pitch(): number;
            set pitch(value: number);
            /** The camera yaw angle, in degrees. */
            get yaw(): number;
            set yaw(value: number);
            /** The camera roll angle, in degrees. */
            get roll(): number;
            set roll(value: number);
            /** The camera vertical field of view angle, in meters. */
            get fov(): number;
            set fov(value: number);
            /** Update controller parameters.
                * @param params Set of parameters to change.
                */
            updateParams(params: Partial<OrthoControllerParams>): void;
            serialize(): ControllerInitParams;
            init(params: ControllerInitParams): void;
            autoFit(center: ReadonlyVec3, radius: number): void;
            moveTo(targetPosition: ReadonlyVec3, flyTime?: number, rotation?: ReadonlyQuat): void;
            zoomTo(boundingSphere: BoundingSphere, flyTime?: number): void;
            update(): void;
            stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            /** OrthoController type guard function.
                * @param controller The controller to type guard.
                */
            static is(controller: BaseController): controller is OrthoController;
            /** OrthoController type assert function.
                * @param controller The controller to type assert.
                */
            static assert(controller: BaseController): asserts controller is OrthoController;
    }
    /** Ortho controller initialization parameters.
        * @category Camera Controllers
        */
    export interface OrthoControllerParams {
            /** The interval to use for stepping clipping planes in the depth direction, i.e. when using mouse navigate buttons.
                * @defaultValue 1.0
                */
            readonly stepInterval: number;
            /** Whether to use mouse pointer lock or not.
                * @defaultValue false
                */
            readonly usePointerLock: boolean;
    }
}

declare module '@novorender/api/web_app/controller/flight' {
    import { type ReadonlyVec3, type ReadonlyQuat } from "gl-matrix";
    import { BaseController, type ControllerInitParams, type PickContext } from "@novorender/api/web_app/controller/base";
    import { type RenderStateCamera, type RecursivePartial, type BoundingSphere } from "@novorender/api/core3d";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    /** The flight controller mimics the behaviour of an etheral, hovering drone, allowing unconstrained movements through walls and obstacles.
        * @category Camera Controllers
        */
    export class FlightController extends BaseController {
            /** The context used for pick queries. */
            readonly pick: PickContext;
            kind: string;
            projection: "pinhole";
            /**
                * @param input The input source.
                * @param pick The context used for pick queries.
                */
            constructor(input: ControllerInput, 
            /** The context used for pick queries. */
            pick: PickContext);
            /** Camera position, in world space. */
            get position(): ReadonlyVec3;
            set position(value: ReadonlyVec3);
            /** Computed rotation quaternion, in world space.
                * @remarks
                * This rotation is derived from {@link pitch} and {@link yaw} angles.
                */
            get rotation(): ReadonlyQuat;
            /** The camera pitch angle, in degrees. */
            get pitch(): number;
            set pitch(value: number);
            /** The camera yaw angle, in degrees. */
            get yaw(): number;
            set yaw(value: number);
            /** The camera vertical field of view angle, in degrees. */
            get fov(): number;
            set fov(value: number);
            /** The optional pivot point to orbit around, in world space. */
            get pivot(): Pivot | undefined;
            /** Update controller parameters.
                * @param params Set of parameters to change.
                */
            updateParams(params: RecursivePartial<FlightControllerParams>): void;
            serialize(): ControllerInitParams;
            init(params: ControllerInitParams): void;
            autoFit(center: ReadonlyVec3, radius: number): void;
            moveTo(targetPosition: ReadonlyVec3, flyTime?: number, rotation?: ReadonlyQuat): void;
            zoomTo(boundingSphere: BoundingSphere, flyTime?: number): void;
            update(): void;
            stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            mouseButtonChanged(event: MouseEvent): Promise<void>;
            touchChanged(event: TouchEvent): Promise<void>;
            moveBegin(event: TouchEvent | MouseEvent): Promise<void>;
            /** FlightController type guard function.
                * @param controller The controller to type guard.
                */
            static is(controller: BaseController): controller is FlightController;
            /** FlightController type assert function.
                * @param controller The controller to type assert.
                */
            static assert(controller: BaseController): asserts controller is FlightController;
    }
    /** Variant of flight controller that uses middle mouse button for panning.
        * @category Camera Controllers
        */
    export class CadMiddlePanController extends FlightController {
            readonly pick: PickContext;
            kind: "cadMiddlePan";
            constructor(input: ControllerInput, pick: PickContext, params?: FlightControllerParams);
            getTransformations(): CameraTransformations;
    }
    /** Variant of flight controller that uses right mouse button for panning.
        * @category Camera Controllers
        */
    export class CadRightPanController extends FlightController {
            readonly pick: PickContext;
            kind: "cadRightPan";
            constructor(input: ControllerInput, pick: PickContext, params?: FlightControllerParams);
            getTransformations(): CameraTransformations;
    }
    /** Vassbakk's super special flight controller.
        * @category Camera Controllers
        */
    export class SpecialFlightController extends FlightController {
            readonly pick: PickContext;
            kind: "special";
            constructor(input: ControllerInput, pick: PickContext, params?: FlightControllerParams);
            getTransformations(): CameraTransformations;
    }
    /** Flight controller initialization parameters
        * @category Camera Controllers
        */
    export interface FlightControllerParams {
            /** The camera linear velocity factor.
                * @defaultValue 1
                */
            linearVelocity: number;
            /** The camera rotational velocity factor.
                * @defaultValue 1
                */
            rotationalVelocity: number;
            /** Delay for pick updates, in milliseconds.
                * @defaultValue 200
                */
            pickDelay: number;
            /** Option to enable shift to modify mouse wheel speed.
             * @defaultValue false
             */
            enableShiftModifierOnWheel: boolean;
            /**
                * When set, the controller will sample the distance to the pixel under the mouse cursor,
                * or central pinch point, and move the camera with speed proportional to that distance.
                * The min and max determines the bounds of how slow/fast it is allowed to move.
                *
                * Setting this to `null` disables this feature, using a constant speed factor of 1.0.
                * @defaultValue null
                */
            proportionalCameraSpeed: {
                    readonly min: number;
                    readonly max: number;
            } | null;
    }
    interface CameraTransformations {
            tx: number;
            ty: number;
            tz: number;
            rx: number;
            ry: number;
            shouldPivot: boolean;
    }
    interface Pivot {
            center: ReadonlyVec3;
            offset: ReadonlyVec3;
            distance: number;
            active: boolean;
    }
    export {};
}

declare module '@novorender/api/web_app/controller/panorama' {
    import { type ReadonlyVec3, type ReadonlyQuat } from "gl-matrix";
    import { BaseController, type ControllerInitParams } from "@novorender/api/web_app/controller/base";
    import { type RenderStateCamera } from "@novorender/api/core3d";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    /** Panorama type camera motion controller
        * @remarks
        * For rotating the camera inside a sphere with a panorama image projected onto it.
        * @category Camera Controllers
        */
    export class PanoramaController extends BaseController {
            kind: "panorama";
            projection: "pinhole";
            /**
                * @param input The input source.
                */
            constructor(input: ControllerInput);
            /** Camera position, in world space. */
            get position(): ReadonlyVec3;
            set position(value: ReadonlyVec3);
            /** Computed rotation quaternion, in world space.
                * @remarks
                * This rotation is derived from {@link pitch} and {@link yaw} angles.
                */
            get rotation(): ReadonlyQuat;
            /** The camera pitch angle, in degrees. */
            get pitch(): number;
            set pitch(value: number);
            /** The camera yaw angle, in degrees. */
            get yaw(): number;
            set yaw(value: number);
            /** The camera vertical field of view angle, in degrees. */
            get fov(): number;
            set fov(value: number);
            /** Update controller parameters.
                * @param params Set of parameters to change.
                */
            updateParams(params: Partial<PanoramaControllerParams>): void;
            serialize(): ControllerInitParams;
            init(params: ControllerInitParams): void;
            autoFit(center: ReadonlyVec3, radius: number): void;
            moveTo(targetPosition: ReadonlyVec3, flyTime?: number, rotation?: ReadonlyQuat): void;
            update(): void;
            stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            /** PanoramaController type guard function.
                * @param controller The controller to type guard.
                */
            static is(controller: BaseController): controller is PanoramaController;
            /** PanoramaController type assert function.
                * @param controller The controller to type assert.
                */
            static assert(controller: BaseController): asserts controller is PanoramaController;
    }
    /** Panorama camera controller parameters
        * @category Camera Controllers
        */
    export interface PanoramaControllerParams {
            /** The camera rotational velocity factor.
                * @defaultValue 1
                */
            rotationalVelocity: number;
    }
}

declare module '@novorender/api/web_app/controller/null' {
    import { type ReadonlyVec3 } from "gl-matrix";
    import { BaseController, type ControllerInitParams } from "@novorender/api/web_app/controller/base";
    import { type RenderStateCamera } from "@novorender/api/core3d";
    import { ControllerInput } from "@novorender/api/web_app/controller/input";
    /** Null type camera motion controller.
        * @remarks
        * This controller is completely passive and will not overwrite/modify any camera render state.
        * @category Camera Controllers
        */
    export class NullController extends BaseController {
            kind: "null";
            projection: undefined;
            /**
                * @param input The input source.
                */
            constructor(input: ControllerInput);
            serialize(): ControllerInitParams;
            init(params: ControllerInitParams): void;
            autoFit(center: ReadonlyVec3, radius: number): void;
            update(): void;
            stateChanges(state?: RenderStateCamera): Partial<RenderStateCamera>;
            /** NullController type guard function.
                * @param controller The controller to type guard.
                */
            static is(controller: BaseController): controller is NullController;
            /** NullController type assert function.
                * @param controller The controller to type assert.
                */
            static assert(controller: BaseController): asserts controller is NullController;
    }
}

declare module '@novorender/api/web_app/controller/orientation' {
    import { type ReadonlyQuat, quat } from "gl-matrix";
    /** A 3D rotation expressed as pitch, roll and yaw angles.
        * @see {@link https://en.wikipedia.org/wiki/Aircraft_principal_axes}
        * @category Camera Controllers
        */
    export class PitchRollYawOrientation {
            /**
                * @param pitch Pitch angle, in degrees.
                * @param yaw Yaw angle, in degrees.
                * @param roll Roll angle, in degrees.
                */
            constructor(pitch?: number, yaw?: number, roll?: number);
            /** Pitch angle, in degrees. */
            get pitch(): number;
            set pitch(value: number);
            /** Roll angle, in degrees. */
            get roll(): number;
            set roll(value: number);
            /** Yaw angle, in degrees. */
            get yaw(): number;
            set yaw(value: number);
            /** Rotation expressed as a quaternion.
                * @remarks
                * The rotation will return a new object if after pitch, roll or yaw angles have changed since last time this accessor was called.
                * Othewise, it returns the previous, cached, object.
                * This enables {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality | strict equality}
                * to determine when the rotation remains unchanged.
                * @see {@link https://glmatrix.net/docs/module-quat.html}
                */
            get rotation(): ReadonlyQuat;
            /** Set pitch, roll and yaw angles from rotation quaternion.
                * @param rot The rotation quaternion to decompose into angles.
                */
            decomposeRotation(rot: ReadonlyQuat): void;
    }
    /** Compute rotation quaternion from roll, pitch and yaw angles.
        * @param roll Roll angle in degrees,
        * @param pitch Pitch angle in degrees,
        * @param yaw Yaw angle in degrees,
        * @category Camera Controllers
        */
    export function computeRotation(roll: number, pitch: number, yaw: number): quat;
    /** Decompose rotation quaternioan into roll, pitch and yaw angles.
        * @param rot Rotation quaternion.
        * @returns Rotation angles in radians.
        * @category Camera Controllers
        */
    export function decomposeRotation(rot: ReadonlyQuat): {
            /** The yaw angle, in radians. */
            readonly yaw: number;
            /** The pitch angle, in radians. */
            readonly pitch: number;
            /** The roll angle, in radians. */
            readonly roll: number;
    };
}

declare module '@novorender/api/web_app/serviceWorker/helper' {
    export {};
}

declare module '@novorender/api/web_app/serviceWorker/promiseBag' {
    export {};
}

declare module '@novorender/api/core3d/state/types' {
    /** Color, expressed as a tuple of red, green and blue with values between 0.0 and 1.0. */
    export type RGB = readonly [red: number, green: number, blue: number];
    /** Color with alpha opacity, expressed as a tuple of red, green, blue and alpha with values between 0.0 and 1.0. */
    export type RGBA = readonly [red: number, green: number, blue: number, alpha: number];
    /** Helper type for arrays of fixed size */
    export type FixedSizeArray<N extends number, T> = N extends 0 ? never[] : {
        0: T;
        length: N;
    } & ReadonlyArray<T>;
    /** Helper type, like typescript's `Partial<T>`, only recursive. */
    export type RecursivePartial<T> = {
        [P in keyof T]?: RecursivePartial<T[P]>;
    };
    /** Helper type, like typescript's `Partial<T>`, but where at least one property must be defined. */
    export type AtLeastOne<T, U = {
        [K in keyof T]: Pick<T, K>;
    }> = Partial<T> & U[keyof U];
}

declare module '@novorender/api/core3d/state/scene' {
    import type { ReadonlyVec3, ReadonlyMat4 } from "gl-matrix";
    /** Static, streamable geometry render state.
        * @remarks
        * Any change to this state will trigger a complete reload of the streamable scene.
        * @category Render State
        */
    export interface RenderStateScene {
            /** Base url whence the scene was downloaded. */
            readonly url: string;
            /** The scene configuration. */
            readonly config: SceneConfig;
            /** Flags for whether to hide/filter various kinds of geometry. */
            readonly hide?: RenderStateStaticGeometryKinds;
    }
    /** Axis-aligned bounding box
        * @category Render State
        */
    export interface AABB {
            /** Minimum coordinates. */
            readonly min: ReadonlyVec3;
            /** Maximum coordinates. */
            readonly max: ReadonlyVec3;
    }
    /** Bounding sphere
        * @category Render State
        */
    export interface BoundingSphere {
            /** Sphere center. */
            readonly center: ReadonlyVec3;
            /** Sphere radius. */
            readonly radius: number;
    }
    /** Scene materials property arrays, encoded as base 64 strings.
        * @category Render State
        */
    export interface MaterialProperties {
            /** Diffuse color properties. */
            readonly diffuse: {
                    readonly red: Base64String;
                    readonly green: Base64String;
                    readonly blue: Base64String;
            };
            /** Opacity properties. */
            readonly opacity: Base64String;
            /** Specular properties. */
            readonly specular: {
                    readonly red: Base64String;
                    readonly green: Base64String;
                    readonly blue: Base64String;
            };
            /** Shininess properties. */
            readonly shininess: Base64String;
    }
    /** Flags for what types of geometry to render or not.
        * @category Render State
        */
    export interface RenderStateStaticGeometryKinds {
            /** Whether to render terrain geometry. */
            readonly terrain?: boolean;
            /** Whether to render (non-terrain) triangles. */
            readonly triangles?: boolean;
            /** Whether to render lines. */
            readonly lines?: boolean;
            /** Whether to render point (clouds). */
            readonly points?: boolean;
            /** Whether to render document geometry, e.g. rendered PDF. */
            readonly documents?: boolean;
    }
    /** Scene Configuration
        * @category Render State
        */
    export interface SceneConfig {
            /** Scene kind. */
            readonly kind: "octree";
            /** Scene id. */
            readonly id: string;
            /** Binary format version. */
            readonly version: string;
            /** Weighted center point of scene, in world space. */
            readonly center: ReadonlyVec3;
            /** Offset used to geo reference scene, in world space. */
            readonly offset: ReadonlyVec3;
            /** Scene bounding sphere, in world space. */
            readonly boundingSphere: BoundingSphere;
            /** Scene bounding box, in world space. */
            readonly aabb: AABB;
            /** Byte size of root node. */
            readonly rootByteSize: number;
            /** Total # of selectable objects in scene. */
            readonly numObjects: number;
            /** Total # of materials in scene. */
            readonly numMaterials: number;
            /** Scene material properties. */
            readonly materialProperties: MaterialProperties;
            /** Model to world space transformation matrix. */
            readonly modelWorldMatrix?: ReadonlyMat4;
            /** List of geometry type subtrees within this scene. */
            readonly subtrees?: ("" | "terrain" | "triangles" | "lines" | "points" | "documents")[];
            /** Optional point cloud attributes. */
            readonly variants?: ("deviation" | "intensity")[];
            /** Binary root node meta information */
            readonly root: Base64String;
    }
}

declare module '@novorender/api/core3d/state/dynamic' {
    import type { ReadonlyMat3, ReadonlyQuat, ReadonlyVec3 } from "gl-matrix";
    import type { DrawMode, MagFilterString, MinFilterString, RGBA, TextureParams2DUncompressed, VertexAttribute, WrapString } from "@novorender/api/webgl2";
    import type { RGB } from "@novorender/api/core3d/state/types";
    /** Texture image related state.
        * @category Render State
        */
    export interface RenderStateDynamicImage {
            /** The parameters for to 2D, uncompressed texture creation. */
            readonly params: TextureParams2DUncompressed;
    }
    /** Texture sampled related state
        * @category Render State
        * @see
        * https://en.wikipedia.org/wiki/Texture_filtering
        * https://learnopengl.com/Getting-started/Textures
        */
    export interface RenderStateDynamicSampler {
            /** Minification filter
                * @defaultValue `"NEAREST_MIPMAP_LINEAR"`
                */
            readonly minificationFilter?: MinFilterString;
            /** Magnification filter
                * @defaultValue `"LINEAR"`
                */
            readonly magnificationFilter?: MagFilterString;
            /** Tuple of S and T wrap mode, respectively.
                * @defaultValue `["REPEAT", "REPEAT"]`
                */
            readonly wrap?: readonly [WrapString, WrapString];
    }
    /** Texture related state.
        * @category Render State
        */
    export interface RenderStateDynamicTexture {
            /** Image to use for this texture */
            readonly image: RenderStateDynamicImage;
            /** Sampler to use for this texture
                * @defaultValue Sampler with all default values.
                */
            readonly sampler?: RenderStateDynamicSampler;
    }
    /** Texture reference state.
        * @category Render State
        */
    export interface RenderStateDynamicTextureReference {
            /** What texture to use. */
            readonly texture: RenderStateDynamicTexture;
            /** What set of texture coordinates to use (0 or 1).
                * @defaultValue 0
                */
            readonly texCoord?: 0 | 1;
            /** Optional texture coordinate 3x3 transformation matrix
                * @defaultValue Identity matrix.
                */
            readonly transform?: ReadonlyMat3;
    }
    /** Normal map texture reference state.
        * @category Render State
        */
    export interface RenderStateDynamicNormalTextureReference extends RenderStateDynamicTextureReference {
            /** Scale factor to apply to normal XY coordinate.
                * @defaultValue 1.0
                */
            readonly scale?: number;
    }
    /** Occlusion map texture reference state.
         * @category Render State
     */
    export interface RenderStateDynamicOcclusionTextureReference extends RenderStateDynamicTextureReference {
            /** Strength factor to apply to occlusion [0.0, 1.0].
                * @defaultValue 1.0
                */
            readonly strength?: number;
    }
    /** Vertex attribute type for dynamic objects.
        * @category Render State
        */
    export type RenderStateDynamicVertexAttribute = Omit<VertexAttribute, "buffer"> & {
            readonly buffer: BufferSource;
    };
    /** Dynamic mesh vertex attributes state.
        * @category Render State
        */
    export interface RenderStateDynamicVertexAttributes {
            /** Vertex position. */
            readonly position: RenderStateDynamicVertexAttribute;
            /** Vertex normal. */
            readonly normal?: RenderStateDynamicVertexAttribute;
            /** Vertex tangent.
                * @remarks Bi-tangent is computed from normal and tangent, if needed.
                */
            readonly tangent?: RenderStateDynamicVertexAttribute;
            /** Vertex color. */
            readonly color0?: RenderStateDynamicVertexAttribute;
            /** Vertex texture coordinate, set 0. */
            readonly texCoord0?: RenderStateDynamicVertexAttribute;
            /** Vertex texture coordinate, set 1. */
            readonly texCoord1?: RenderStateDynamicVertexAttribute;
    }
    /** Dynamic mesh geometry state.
        * @category Render State
        */
    export interface RenderStateDynamicGeometry {
            /** Type of render primitive. */
            readonly primitiveType: DrawMode;
            /** Vertex attributes. */
            readonly attributes: RenderStateDynamicVertexAttributes;
            /** Array of Vertex indices, or # vertices if mesh is not indexed. */
            readonly indices: Uint32Array | Uint16Array | Uint8Array | number;
    }
    /** Dynamic mesh primitive.
        * @remarks
        * Meshes are rendered one material at a time.
        * This interfaces describes such a sub-mesh, or mesh primitive
        * @category Render State
        */
    export interface RenderStateDynamicMeshPrimitive {
            /** What dynamic mesh geometry to use. */
            readonly geometry: RenderStateDynamicGeometry;
            /** What dynamic mesh material to use. */
            readonly material: RenderStateDynamicMaterial;
    }
    /** Dynamic mesh render state.
        * @category Render State
        */
    export interface RenderStateDynamicMesh {
            /** Array of geometry+material sub meshes. */
            readonly primitives: readonly RenderStateDynamicMeshPrimitive[];
    }
    /** Common material properties.
        * @category Render State
        */
    interface RenderStateDynamicMaterialCommon {
            /** Whether to render material as double sided or not.
                * @default: false
                */
            readonly doubleSided?: boolean;
            /** How to interpret color alpha channel.
                * @remarks
                * `"OPAQUE"` renders all pixels regardless of alpha value.
                *
                * `"MASK"` renders only pixels with alpha larger or equal to {@link alphaCutoff}.
                *
                * `"BLEND"` blends pixels with background using alpha as blending factor.
                */
            readonly alphaMode?: "OPAQUE" | "MASK" | "BLEND";
            /** Cutoff factor used for alpha masking.
                * @defaultValue 0.5
                */
            readonly alphaCutoff?: number;
    }
    /** Unlit material properties.
        * @category Render State
        */
    export interface RenderStateDynamicMaterialUnlit extends RenderStateDynamicMaterialCommon {
            /** Material union discriminant. */
            readonly kind: "unlit";
            /** Factor used directly or multiplied with {@link baseColorTexture}, if defined, for material base color.
                * @defaultValue `[1,1,1,1]`
                */
            readonly baseColorFactor?: RGBA;
            /** Base color texture. */
            readonly baseColorTexture?: RenderStateDynamicTextureReference;
    }
    /** GGX type of PBR material.
        * @see https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#materials
        * @category Render State
        */
    export interface RenderStateDynamicMaterialGGX extends RenderStateDynamicMaterialCommon {
            /** Material union discriminant. */
            readonly kind: "ggx";
            /** Factor used directly or multiplied with {@link baseColorTexture}, if defined, for material base color.
                * @defaultValue `[1,1,1,1]`
                */
            readonly baseColorFactor?: RGBA;
            /** Metallicness PBR factor (0-1)
                * @defaultValue 1
                */
            readonly metallicFactor?: number;
            /** Roughness PBR factor (0-1)
                * @defaultValue 1
                */
            readonly roughnessFactor?: number;
            /** Emissive light factor (0-1)
                * @defaultValue 1
                */
            readonly emissiveFactor?: RGB;
            /** Base color texture. */
            readonly baseColorTexture?: RenderStateDynamicTextureReference;
            /** PBR Mmtallic + roughness texture.
                * @see https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#metallic-roughness-material
                */
            readonly metallicRoughnessTexture?: RenderStateDynamicTextureReference;
            /** PBR surface normal texture  */
            readonly normalTexture?: RenderStateDynamicNormalTextureReference;
            /** Occlusion/AO texture  */
            readonly occlusionTexture?: RenderStateDynamicOcclusionTextureReference;
            /** Emissive light texture */
            readonly emissiveTexture?: RenderStateDynamicTextureReference;
    }
    /** Material related render state.
        * @category Render State
        */
    export type RenderStateDynamicMaterial = RenderStateDynamicMaterialUnlit | RenderStateDynamicMaterialGGX;
    /** Dynamic object instance render state.
        * @category Render State
        */
    export interface RenderStateDynamicInstance {
            /** Object instance position, in world space. */
            readonly position: ReadonlyVec3;
            /** Object instance rotation, in world space. */
            readonly rotation?: ReadonlyQuat;
    }
    /** Dynamic object related render state.
        * @category Render State
        */
    export interface RenderStateDynamicObject {
            /** What mesh to render. */
            readonly mesh: RenderStateDynamicMesh;
            /**
                * Object instances
                * @remarks
                * Instances renders the same mesh once for reach instance at a unique position and rotation.
                * This is accomplished by using GPU instancing,
                * which means there is very little overhead per instance.
                * As long as the total triangle count remains tolerable, thousands of instances is no problem.
                * @see https://learnopengl.com/Advanced-OpenGL/Instancing
                */
            readonly instances: readonly RenderStateDynamicInstance[];
            /** What base object id/index to use for object instances.*/
            readonly baseObjectId?: number;
    }
    /**
        * Dynamic object related render state
        * @remarks
        * Unlike static/streamable geometry, dynamic objects can be moved and rotated freely.
        * They do not support level of detail (LOD), however, so care must be taken not to use excessive amount of triangles/primitives.
        * Also, geometry is kept both in javascript memory in the form of render state,
        * and also in GPU/WebGL2 memory as renderable geometry,
        * so avoid complex, memory consuming models if possible.
        * Dynamic objects can be created procedurally or by loading a glTF2 file {@link loadGLTF}.
        *
        * Since there is a significant overlap between the {@link https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html | gltf2 specifications} and this render state,
        * you may read the glTF2 specs to learn more details.
        * @category Render State
        */
    export interface RenderStateDynamicObjects {
            /** Dynamic objects to render. */
            readonly objects: readonly RenderStateDynamicObject[];
    }
    export {};
}

declare module '@novorender/api/core3d/state/default' {
    import { type RenderState } from "@novorender/api/core3d/state";
    /** Create a default render state. */
    export function defaultRenderState(): RenderState;
}

declare module '@novorender/api/core3d/state/modify' {
    import type { RenderState, RenderStateChanges } from "@novorender/api/core3d/state";
    /**
        * Create a new copy of render state with specified modifications.
        * @param state The baseline render state.
        * @param changes The changes to apply to the baseline state.
        * @returns A new render state with all the changes applied.
        * @remarks
        * This function helps you modify render state in an immutable fashion,
        * which is key for correct and efficient render updates.
        * More specifically, it leaves all the unchanged sub objects of the returned render state alone.
        * This enables checking for changes using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality | strict equality}.
        * Making unnecessary copies of unchanged sub objects will reduce render/update performance.
        *
        * This function also performs some basic validation of the new state changes, at a slight performance cost.
        * To mitigate this overhead, accumulating all the changes for a frame into a single object may be beneficial.
        * The {@link mergeRecursive} function may be useful in for this.
        * @category Render State
        */
    export function modifyRenderState(state: RenderState, changes: RenderStateChanges): RenderState;
    /**
        * Utility function for merging the properties of two objects recursively
        * @param original Original, baseline object.
        * @param changes Changes to be applied to baseline object.
        * @returns A clone of the original with all the changes applied.
        * @remarks
        * This function is similar to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign | Object.assign}, only recursive.
        */
    export function mergeRecursive(original: any, changes: any): any;
}

declare module '@novorender/api/webgl2' {
    export * from "@novorender/api/webgl2/blit";
    export * from "@novorender/api/webgl2/buffer";
    export * from "@novorender/api/webgl2/clear";
    export * from "@novorender/api/webgl2/copy";
    export * from "@novorender/api/webgl2/delete";
    export * from "@novorender/api/webgl2/draw";
    export * from "@novorender/api/webgl2/extensions";
    export * from "@novorender/api/webgl2/frameBuffer";
    export * from "@novorender/api/webgl2/limits";
    export * from "@novorender/api/webgl2/misc";
    export * from "@novorender/api/webgl2/program";
    export * from "@novorender/api/webgl2/read";
    export * from "@novorender/api/webgl2/renderBuffer";
    export * from "@novorender/api/webgl2/sampler";
    export * from "@novorender/api/webgl2/state";
    export * from "@novorender/api/webgl2/texture";
    export * from "@novorender/api/webgl2/timer";
    export * from "@novorender/api/webgl2/transformFeedback";
    export * from "@novorender/api/webgl2/uniforms";
    export * from "@novorender/api/webgl2/vao";
}

declare module '@novorender/api/core3d/buffers' {
    import type { ResourceBin } from "@novorender/api/core3d/resource";
    export const enum BufferFlags {
        color = 1,
        pick = 2,
        depth = 4,
        all = 7
    }
    /**
      * Set of buffers uses for rendering and pick.
      * @remarks
      * These buffers are only useful for advanced developers who aim to extend this API with their own custom 3D module.
      * @category Render Module
      */
    export class RenderBuffers {
        /** The underlying webgl2 rendering context. */
        readonly gl: WebGL2RenderingContext;
        /** The buffer width in pixels. */
        readonly width: number;
        /** The buffer height in pixels. */
        readonly height: number;
        /** # of MSAA samples. */
        readonly samples: number;
        /** The resource bin to manage resource tracking and disposal. */
        readonly resourceBin: ResourceBin;
        /** Flag to indicate the CPU/read buffers needs to be updated. */
        readBuffersNeedUpdate: boolean;
        /** Texture resources. */
        readonly textures: {
            readonly color: WebGLTexture;
            readonly pick: WebGLTexture;
            readonly depth: WebGLTexture;
        };
        /** Renderbuffer resources. */
        readonly renderBuffers: {
            readonly colorMSAA: WebGLRenderbuffer | null;
            readonly depthMSAA: WebGLRenderbuffer | null;
        };
        /** Frame buffer resources. */
        readonly frameBuffers: {
            readonly color: WebGLFramebuffer;
            readonly colorMSAA: WebGLFramebuffer | null;
            readonly pick: WebGLFramebuffer;
        };
        /** CPU/JS copy of pick buffers. */
        readonly readBuffers: {
            readonly pick: WebGLBuffer;
        };
    }
}

declare module '@novorender/api/core3d/resource' {
    import { type WebGLResource, type BufferParams, type BufferTargetString, type FrameBufferParams, type ProgramParams, type RenderbufferParams, type SamplerParams, type TextureParams, type TextureTargetString, type VertexArrayParams, type ProgramAsyncParams } from "@novorender/api/webgl2";
    /**
      * A WebGL resource tracking helper class.
      * @remarks
      * Resource bins are used to track allocation of WebGL resources and assist with automatic disposal.
      * @category Render Module
      */
    export class ResourceBin {
        /** The underlying WebGL2 rendering context. */
        readonly gl: WebGL2RenderingContext;
        /** The name of the resource bin. */
        readonly name: string;
        get resourceInfo(): IterableIterator<ResourceInfo>;
        get size(): number;
        createBuffer(params: BufferParams): WebGLBuffer;
        createFrameBuffer(params: FrameBufferParams): WebGLFramebuffer;
        createProgram(params: ProgramParams): WebGLProgram;
        createProgramAsync(params: ProgramAsyncParams): {
            readonly program: WebGLProgram;
            readonly vertex: WebGLShader;
            readonly fragment: WebGLShader;
        };
        createRenderBuffer(params: RenderbufferParams): WebGLRenderbuffer;
        createSampler(params: SamplerParams): WebGLSampler;
        createTexture(params: TextureParams): WebGLTexture;
        createTransformFeedback(): WebGLTransformFeedback;
        createVertexArray(params: VertexArrayParams): WebGLVertexArrayObject;
        subordinate(owner: WebGLVertexArrayObject | WebGLFramebuffer, ...resources: readonly (WebGLResource | null)[]): void;
        delete(...resources: readonly (WebGLResource | null)[]): void;
        deleteAll(): void;
        dispose(): void;
    }
    const resourceKinds: readonly ["Buffer", "Framebuffer", "Program", "Query", "Renderbuffer", "Sampler", "Shader", "Sync", "TransformFeedback", "Texture", "VertexArray"];
    export type ResourceKind = typeof resourceKinds[number];
    export type ResourceTarget = BufferTargetString | TextureTargetString | "FRAMEBUFFER";
    export interface ResourceInfo {
        readonly kind: ResourceKind;
        readonly target?: ResourceTarget;
        readonly byteSize?: number;
        readonly tag?: string;
    }
    export {};
}

declare module '@novorender/api/core3d/benchmark/benchmark' {
    /** A basic GPU benchmark helper class.
      * @category Device Profile
      */
    export class Benchmark {
        readonly canvas: HTMLCanvasElement;
        readonly gl: WebGL2RenderingContext;
        static readonly size = 1024;
        static readonly numPixels: number;
        constructor();
        /** Dispose of created GPU resources. */
        dispose(): void;
    }
}

declare module '@novorender/api/core3d/benchmark/fillrate' {
    import { Benchmark } from "@novorender/api/core3d/benchmark/benchmark";
    import type { ShaderImports } from "core3d/shaders";
    /** A basic GPU fill rate profiler.
        * @category Device Profile
        */
    export class FillrateProfiler {
            /** The benchmark context. */
            readonly benchmark: Benchmark;
            readonly program: WebGLProgram;
            readonly uniforms: Record<"seed", WebGLUniformLocation | null>;
            /**
                * @param benchmark The benchmark context to use.
                * @param shaders The shader imports.
                */
            constructor(
            /** The benchmark context. */
            benchmark: Benchmark, shaders: ShaderImports["benchmark"]);
            /**
                * Measure fill rate by rendering a series of noisy, semi-transparent quads.
                * @returns Fill rate estimate in pixels/second.
                * @remarks
                * This test is quite inaccurate and does not match close to the nominal fill rate of a GPU, particularly on tile based mobile GPUs.
                * The result should only serve as a rough estimate.
                */
            measure(): Promise<number>;
    }
}

declare module '@novorender/api/core3d/benchmark/pointrate' {
    import { Benchmark } from "@novorender/api/core3d/benchmark/benchmark";
    import type { ShaderImports } from "core3d/shaders";
    /** A basic GPU point rate profiler.
        * @category Device Profile
        */
    export class PointrateProfiler {
            /** The benchmark context. */
            readonly benchmark: Benchmark;
            readonly program: WebGLProgram;
            readonly uniforms: Record<"color", WebGLUniformLocation | null>;
            /**
                * @param benchmark The benchmark context to use.
                * @param shaders The shader imports.
                */
            constructor(
            /** The benchmark context. */
            benchmark: Benchmark, shaders: ShaderImports["benchmark"]);
            /**
                * Measure fill rate by rendering a series of noisy, semi-transparent point primitives.
                * @returns Primitive/point rate estimate in primitives/second.
                * @remarks
                * This test is quite inaccurate and does not match close to the nominal primitive/triangle rate of a GPU, particularly on tile based mobile GPUs.
                * Points are being used instead of triangles since they more closely reflect the maximum theoretical primitive rate of most GPUs.
                * The result should only serve as a rough estimate.
                */
            measure(): Promise<number>;
    }
}

declare module '@novorender/api/core3d/wasm/float16' {
    /** The webassembly instance for float16/32 conversion functions
        * @remarks
        * Ecmascript currently has no typed array for float16.
        * We work around this by using a Uint16Array and then do the bitwise conversion to and from float32 that javascript can understand.
        * @see
        * {@link https://en.wikipedia.org/wiki/Half-precision_floating-point_format#IEEE_754_half-precision_binary_floating-point_format:_binary16 | float16 }
        * {@link https://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_standard:_binary32 | float32 }
        */
    export interface Float16Instance {
            /**
                * Convert a float16 to float32
                * @param f16 A float16, expressed as a 16 bit unsigned integer.
                * @returns The converted value as a regular floating point number.
                * @remarks
                * This function does not handle NANs or INFs.
                */
            float32(f16: number): number;
            /**
                * Convert a float32 to float16
                * @param f32 A float16, expressed as a regular floating point number.
                * @returns The converted value as a float16, expressed as a 16 bit unsigned integer
                * @remarks
                * This function does not handle NANs or INFs.
                */
            float16(f32: number): number;
    }
}

declare module '@novorender/api/webgl2/blit' {
    /** @public */
    export function glBlit(gl: WebGL2RenderingContext, params: BlitParams): void;
    export interface BlitParams {
        readonly source: WebGLFramebuffer | null;
        readonly destination: WebGLFramebuffer | null;
        readonly color?: true;
        readonly depth?: true;
        readonly stencil?: true;
        readonly filter?: "NEAREST" | "LINEAR";
        readonly srcX0?: number;
        readonly srcY0?: number;
        readonly srcX1?: number;
        readonly srcY1?: number;
        readonly dstX0?: number;
        readonly dstY0?: number;
        readonly dstX1?: number;
        readonly dstY1?: number;
    }
}

declare module '@novorender/api/webgl2/buffer' {
    export function glCreateBuffer(gl: WebGL2RenderingContext, params: BufferParams): WebGLBuffer;
    export function glUpdateBuffer(gl: WebGL2RenderingContext, params: UpdateParams): void;
    export type BufferParams = BufferParamsSize | BufferParamsData;
    export type BufferTargetString = "ARRAY_BUFFER" | "ELEMENT_ARRAY_BUFFER" | "COPY_READ_BUFFER" | "COPY_WRITE_BUFFER" | "TRANSFORM_FEEDBACK_BUFFER" | "UNIFORM_BUFFER" | "PIXEL_PACK_BUFFER" | "PIXEL_UNPACK_BUFFER";
    export type BufferUsageString = "STATIC_DRAW" | "DYNAMIC_DRAW" | "STREAM_DRAW" | "STATIC_READ" | "DYNAMIC_READ" | "STREAM_READ" | "STATIC_COPY" | "DYNAMIC_COPY" | "STREAM_COPY";
    export interface BufferParamsSize {
        readonly kind: BufferTargetString;
        readonly byteSize: GLsizeiptr;
        readonly usage?: BufferUsageString;
    }
    export interface BufferParamsData {
        readonly kind: BufferTargetString;
        readonly srcData: BufferSource;
        readonly usage?: BufferUsageString;
    }
    export interface UpdateParams {
        readonly kind: BufferTargetString;
        readonly srcData: BufferSource;
        readonly targetBuffer: WebGLBuffer;
        readonly srcElementOffset?: number;
        readonly dstByteOffset?: number;
        readonly byteSize?: number;
    }
}

declare module '@novorender/api/webgl2/clear' {
    export function glClear(gl: WebGL2RenderingContext, params: ClearParams): void;
    export type ClearParams = ClearParamsBack | ClearParamsColor | ClearDepth | ClearStencil | ClearDepthStencil;
    export interface ClearParamsBack {
        readonly kind: "back_buffer";
        readonly color?: readonly [red: number, green: number, blue: number, alpha: number];
        readonly depth?: number;
        readonly stencil?: number;
    }
    export interface ClearParamsColor {
        readonly kind: "COLOR";
        readonly drawBuffer?: number;
        readonly color?: readonly [red: number, green: number, blue: number, alpha: number];
        readonly type?: "Int" | "Uint" | "Float";
    }
    export interface ClearDepth {
        readonly kind: "DEPTH";
        readonly drawBuffer?: number;
        readonly depth: number;
    }
    export interface ClearStencil {
        readonly kind: "STENCIL";
        readonly drawBuffer?: number;
        readonly stencil: number;
    }
    export interface ClearDepthStencil {
        readonly kind: "DEPTH_STENCIL";
        readonly drawBuffer?: number;
        readonly depth: number;
        readonly stencil: number;
    }
}

declare module '@novorender/api/webgl2/copy' {
    export function glCopy(gl: WebGL2RenderingContext, params: CopyParams): void;
    export interface CopyParams {
        readonly readBuffer: WebGLBuffer;
        readonly writeBuffer: WebGLBuffer;
        readonly readByteOffset?: number;
        readonly writeByteOffset?: number;
        readonly byteSize: number;
    }
}

declare module '@novorender/api/webgl2/delete' {
    export function glDelete(gl: WebGL2RenderingContext, params: DeleteParams): void;
    export type WebGLResource = WebGLBuffer | WebGLFramebuffer | WebGLProgram | WebGLQuery | WebGLRenderbuffer | WebGLSampler | WebGLShader | WebGLSync | WebGLTransformFeedback | WebGLTexture | WebGLTransformFeedback | WebGLVertexArrayObject;
    export type DeleteParams = WebGLResource | readonly WebGLResource[] | WebGLResourceContainer | null;
    export type WebGLResourceContainer = {
        readonly [key: string]: WebGLResource | null;
    };
}

declare module '@novorender/api/webgl2/draw' {
    export function glDraw(gl: WebGL2RenderingContext, params: DrawParams): DrawStatistics;
    export type DrawStatistics = {
        readonly points: number;
        readonly lines: 0;
        readonly triangles: 0;
    } | {
        readonly points: 0;
        readonly lines: number;
        readonly triangles: 0;
    } | {
        readonly points: 0;
        readonly lines: 0;
        readonly triangles: number;
    };
    export type DrawParams = DrawParamsArrays | DrawParamsArraysMultiDraw | DrawParamsArraysInstanced | DrawParamsElements | DrawParamsElementsRange | DrawParamsElementsMultiDraw | DrawParamsElementsInstanced;
    export type DrawMode = "POINTS" | "LINE_STRIP" | "LINE_LOOP" | "LINES" | "TRIANGLE_STRIP" | "TRIANGLE_FAN" | "TRIANGLES";
    export interface DrawParamsBase {
        readonly mode?: DrawMode;
    }
    export interface DrawParamsArrays extends DrawParamsBase {
        /** Equivalent to gl.drawArrays() */
        readonly kind: "arrays";
        readonly count: number;
        readonly first?: number;
    }
    export interface DrawParamsArraysMultiDraw extends DrawParamsBase {
        /** Equivalent to `ext.multiDrawArraysWEBGL()` */
        readonly kind: "arrays_multidraw";
        readonly drawCount: number;
        readonly firstsList: Int32Array;
        readonly firstsOffset?: number;
        readonly counts: Int32Array;
        readonly countsOffset?: number;
    }
    export interface DrawParamsElements extends DrawParamsBase {
        /** Equivalent to gl.drawElements() */
        readonly kind: "elements";
        /** # of indices to draw */
        readonly count: number;
        /** Type of indices */
        readonly indexType: "UNSIGNED_BYTE" | "UNSIGNED_SHORT" | "UNSIGNED_INT";
        /** Byte offset in the element array buffer. Must be a valid multiple of the size of the given type. */
        readonly byteOffset?: number;
    }
    export interface DrawParamsElementsRange extends DrawParamsBase {
        /** Equivalent to gl.drawRangeElements() */
        readonly kind: "elements_range";
        /** # of indices to draw */
        readonly count: number;
        /** Type of indices */
        readonly indexType: "UNSIGNED_BYTE" | "UNSIGNED_SHORT" | "UNSIGNED_INT";
        /** Byte offset in the element array buffer. Must be a valid multiple of the size of the given type. */
        readonly byteOffset?: number;
        /** The minimum array index contained in buffer range. */
        readonly minIndex: number;
        /** The maximum array index contained in buffer range. */
        readonly maxIndex: number;
    }
    export interface DrawParamsElementsMultiDraw extends DrawParamsBase {
        /** Equivalent to `ext.multiDrawArraysWEBGL()` */
        readonly kind: "elements_multidraw";
        readonly drawCount: number;
        readonly indexType: "UNSIGNED_BYTE" | "UNSIGNED_SHORT" | "UNSIGNED_INT";
        readonly byteOffsets: Int32Array;
        readonly byteOffsetsOffset?: number;
        readonly counts: Int32Array;
        readonly countsOffset?: number;
    }
    export interface DrawParamsArraysInstanced extends DrawParamsBase {
        /** Equivalent to gl.drawArraysInstanced() */
        readonly kind: "arrays_instanced";
        readonly count: number;
        readonly instanceCount: number;
        readonly first?: number;
    }
    export interface DrawParamsElementsInstanced extends DrawParamsBase {
        /** Equivalent to gl.drawElementsInstanced() */
        readonly kind: "elements_instanced";
        readonly count: number;
        readonly instanceCount: number;
        readonly indexType: "UNSIGNED_BYTE" | "UNSIGNED_SHORT" | "UNSIGNED_INT";
        readonly byteOffset?: number;
    }
}

declare module '@novorender/api/webgl2/extensions' {
    export function glExtensions(gl: WebGL2RenderingContext, refresh?: boolean): {
        readonly colorBufferFloat: WEBGL_color_buffer_float | null;
        readonly parallelShaderCompile: KHR_parallel_shader_compile | null;
        readonly loseContext: WEBGL_lose_context | null;
        readonly multiDraw: WEBGL_multi_draw | null;
        readonly drawBuffersIndexed: OES_draw_buffers_indexed_ext | null;
        readonly disjointTimerQuery: EXT_disjoint_timer_query_webgl2_ext;
        readonly provokingVertex: WEBGL_provoking_vertex | null;
    };
    function getWebGL2Extensions(gl: WebGL2RenderingContext): {
        readonly colorBufferFloat: WEBGL_color_buffer_float | null;
        readonly parallelShaderCompile: KHR_parallel_shader_compile | null;
        readonly loseContext: WEBGL_lose_context | null;
        readonly multiDraw: WEBGL_multi_draw | null;
        readonly drawBuffersIndexed: OES_draw_buffers_indexed_ext | null;
        readonly disjointTimerQuery: EXT_disjoint_timer_query_webgl2_ext;
        readonly provokingVertex: WEBGL_provoking_vertex | null;
    };
    export type ExtensionsGL = ReturnType<typeof getWebGL2Extensions>;
    export interface OES_draw_buffers_indexed_ext {
        enableiOES(target: number, index: number): void;
        disableiOES(target: number, index: number): void;
        blendEquationiOES(buf: number, mode: number): void;
        blendEquationSeparateiOES(buf: number, modeRGB: number, modeAlpha: number): void;
        blendFunciOES(buf: number, src: number, dst: number): void;
        blendFuncSeparateiOES(buf: number, srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;
        colorMaskiOES(buf: number, r: boolean, g: boolean, b: boolean, a: boolean): void;
    }
    export interface EXT_disjoint_timer_query_webgl2_ext {
        readonly QUERY_COUNTER_BITS_EXT: 0x8864;
        readonly TIME_ELAPSED_EXT: 0x88BF;
        readonly TIMESTAMP_EXT: 0x8E28;
        readonly GPU_DISJOINT_EXT: 0x8FBB;
        queryCounterEXT(query: WebGLQuery, target: 0x8E28): void;
    }
    export interface WEBGL_provoking_vertex {
        readonly FIRST_VERTEX_CONVENTION_WEBGL: 0x8E4D;
        readonly LAST_VERTEX_CONVENTION_WEBGL: 0x8E4E;
        readonly PROVOKING_VERTEX_WEBGL: 0x8E4F;
        provokingVertexWEBGL(provokeMode: 0x8E4D | 0x8E4E): void;
    }
    export {};
}

declare module '@novorender/api/webgl2/frameBuffer' {
    export function glCreateFrameBuffer(gl: WebGL2RenderingContext, params: FrameBufferParams): WebGLFramebuffer;
    export function glInvalidateFrameBuffer(gl: WebGL2RenderingContext, params: InvalidateFrameBufferParams): void;
    export interface FrameBufferParams {
        readonly depth?: FrameBufferBinding;
        readonly stencil?: FrameBufferBinding;
        readonly color: readonly (FrameBufferBinding | null)[];
    }
    export interface FrameBufferTextureBinding {
        readonly kind: "FRAMEBUFFER" | "DRAW_FRAMEBUFFER" | "READ_FRAMEBUFFER";
        readonly texture: WebGLTexture | null;
        readonly texTarget?: "TEXTURE_2D";
        readonly level?: number;
        readonly layer?: number;
    }
    export interface FrameBufferRenderBufferBinding {
        readonly kind: "FRAMEBUFFER" | "DRAW_FRAMEBUFFER" | "READ_FRAMEBUFFER";
        readonly renderBuffer: WebGLRenderbuffer | null;
    }
    export type FrameBufferBinding = FrameBufferTextureBinding | FrameBufferRenderBufferBinding;
    export interface InvalidateFrameBufferParams {
        readonly kind: "FRAMEBUFFER" | "DRAW_FRAMEBUFFER" | "READ_FRAMEBUFFER";
        readonly frameBuffer: WebGLFramebuffer | null;
        readonly depth?: boolean;
        readonly stencil?: boolean;
        readonly color: readonly (boolean)[];
    }
}

declare module '@novorender/api/webgl2/limits' {
    export function glLimits(gl: WebGL2RenderingContext): Readonly<{
        MAX_TEXTURE_SIZE: number;
        MAX_VIEWPORT_DIMS: number;
        MAX_TEXTURE_IMAGE_UNITS: number;
        MAX_VERTEX_UNIFORM_VECTORS: number;
        MAX_VARYING_VECTORS: number;
        MAX_VERTEX_ATTRIBS: number;
        MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
        MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
        MAX_FRAGMENT_UNIFORM_VECTORS: number;
        MAX_CUBE_MAP_TEXTURE_SIZE: number;
        MAX_RENDERBUFFER_SIZE: number;
        MAX_3D_TEXTURE_SIZE: number;
        MAX_ELEMENTS_VERTICES: number;
        MAX_ELEMENTS_INDICES: number;
        MAX_TEXTURE_LOD_BIAS: number;
        MAX_FRAGMENT_UNIFORM_COMPONENTS: number;
        MAX_VERTEX_UNIFORM_COMPONENTS: number;
        MAX_ARRAY_TEXTURE_LAYERS: number;
        MIN_PROGRAM_TEXEL_OFFSET: number;
        MAX_PROGRAM_TEXEL_OFFSET: number;
        MAX_VARYING_COMPONENTS: number;
        MAX_VERTEX_OUTPUT_COMPONENTS: number;
        MAX_FRAGMENT_INPUT_COMPONENTS: number;
        MAX_SERVER_WAIT_TIMEOUT: number;
        MAX_ELEMENT_INDEX: number;
        MAX_DRAW_BUFFERS: number;
        MAX_COLOR_ATTACHMENTS: number;
        MAX_SAMPLES: number;
        MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: number;
        MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: number;
        MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: number;
        MAX_VERTEX_UNIFORM_BLOCKS: number;
        MAX_FRAGMENT_UNIFORM_BLOCKS: number;
        MAX_COMBINED_UNIFORM_BLOCKS: number;
        MAX_UNIFORM_BUFFER_BINDINGS: number;
        MAX_UNIFORM_BLOCK_SIZE: number;
        MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: number;
        MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: number;
    }>;
    function getWebGL2Limits(gl: WebGL2RenderingContext): Readonly<{
        MAX_TEXTURE_SIZE: number;
        MAX_VIEWPORT_DIMS: number;
        MAX_TEXTURE_IMAGE_UNITS: number;
        MAX_VERTEX_UNIFORM_VECTORS: number;
        MAX_VARYING_VECTORS: number;
        MAX_VERTEX_ATTRIBS: number;
        MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
        MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
        MAX_FRAGMENT_UNIFORM_VECTORS: number;
        MAX_CUBE_MAP_TEXTURE_SIZE: number;
        MAX_RENDERBUFFER_SIZE: number;
        MAX_3D_TEXTURE_SIZE: number;
        MAX_ELEMENTS_VERTICES: number;
        MAX_ELEMENTS_INDICES: number;
        MAX_TEXTURE_LOD_BIAS: number;
        MAX_FRAGMENT_UNIFORM_COMPONENTS: number;
        MAX_VERTEX_UNIFORM_COMPONENTS: number;
        MAX_ARRAY_TEXTURE_LAYERS: number;
        MIN_PROGRAM_TEXEL_OFFSET: number;
        MAX_PROGRAM_TEXEL_OFFSET: number;
        MAX_VARYING_COMPONENTS: number;
        MAX_VERTEX_OUTPUT_COMPONENTS: number;
        MAX_FRAGMENT_INPUT_COMPONENTS: number;
        MAX_SERVER_WAIT_TIMEOUT: number;
        MAX_ELEMENT_INDEX: number;
        MAX_DRAW_BUFFERS: number;
        MAX_COLOR_ATTACHMENTS: number;
        MAX_SAMPLES: number;
        MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: number;
        MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: number;
        MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: number;
        MAX_VERTEX_UNIFORM_BLOCKS: number;
        MAX_FRAGMENT_UNIFORM_BLOCKS: number;
        MAX_COMBINED_UNIFORM_BLOCKS: number;
        MAX_UNIFORM_BUFFER_BINDINGS: number;
        MAX_UNIFORM_BLOCK_SIZE: number;
        MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: number;
        MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: number;
    }>;
    export type LimitsGL = ReturnType<typeof getWebGL2Limits>;
    export {};
}

declare module '@novorender/api/webgl2/misc' {
    export function glErrorMessage(status: number): "Invalid enum" | "Invalid value" | "Invalid operation" | "Invalid framebuffer operation" | "Out of memory" | "Context lost" | "Unknown status" | undefined;
    export function glAttributesInfo(gl: WebGL2RenderingContext, program: WebGLProgram): WebGLActiveInfo[];
    export function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement, scale?: number): boolean;
    export function getPixelFormatChannels(format: string): 1 | 3 | 2 | 4;
    export function getBufferViewType(type: string): Uint8ArrayConstructor | Int8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor | Int32ArrayConstructor | Float32ArrayConstructor;
}

declare module '@novorender/api/webgl2/program' {
    export type ShaderExtensionName = "GL_ANGLE_multi_draw";
    export function glShaderExtensions(gl: WebGL2RenderingContext): IterableIterator<ShaderExtension>;
    export function glCompile(gl: WebGL2RenderingContext, params: ShaderParams): WebGLShader;
    export function glCreateProgramAsync(gl: WebGL2RenderingContext, params: ProgramAsyncParams): {
        readonly program: WebGLProgram;
        readonly vertex: WebGLShader;
        readonly fragment: WebGLShader;
    };
    export function glCheckProgram(gl: WebGL2RenderingContext, params: ReturnType<typeof glCreateProgramAsync>): {
        readonly link: string | null;
        readonly vertex: string | null;
        readonly fragment: string | null;
    } | undefined;
    export function glCreateProgram(gl: WebGL2RenderingContext, params: ProgramParams): WebGLProgram;
    export interface ProgramAsyncParams {
        readonly header?: string | Partial<ShaderHeaderParams>;
        readonly vertexShader: string;
        readonly fragmentShader: string | undefined;
    }
    export interface VertexShaderParams {
        readonly kind: "VERTEX_SHADER";
        readonly shader: string;
    }
    export interface FragmentShaderParams {
        readonly kind: "FRAGMENT_SHADER";
        readonly shader: string;
    }
    export type ShaderParams = VertexShaderParams | FragmentShaderParams;
    export interface ShaderExtension {
        readonly name: ShaderExtensionName | string;
        readonly behaviour: "enable" | "require" | "warn" | "disable";
    }
    export interface ShaderDefine {
        readonly name: string;
        readonly value?: string;
    }
    export type ShaderPrecision = "high" | "medium" | "low";
    export interface ShaderDefaultPrecisions {
        readonly float: ShaderPrecision;
        readonly int: ShaderPrecision;
        readonly sampler2D: ShaderPrecision;
        readonly samplerCube: ShaderPrecision;
        readonly sampler3D: ShaderPrecision;
        readonly samplerCubeShadow: ShaderPrecision;
        readonly sampler2DShadow: ShaderPrecision;
        readonly sampler2DArray: ShaderPrecision;
        readonly sampler2DArrayShadow: ShaderPrecision;
        readonly isampler2D: ShaderPrecision;
        readonly isampler3D: ShaderPrecision;
        readonly isamplerCube: ShaderPrecision;
        readonly isampler2DArray: ShaderPrecision;
        readonly usampler2D: ShaderPrecision;
        readonly usampler3D: ShaderPrecision;
        readonly usamplerCube: ShaderPrecision;
        readonly usampler2DArray: ShaderPrecision;
    }
    export interface ShaderHeaderParams {
        readonly version: "300 es";
        readonly extensions: readonly ShaderExtension[];
        readonly defaultPrecisions: Partial<ShaderDefaultPrecisions>;
        readonly flags: readonly string[];
        readonly defines: readonly ShaderDefine[];
        readonly commonChunk: string;
    }
    export interface ProgramParams {
        readonly vertexShader: string;
        readonly fragmentShader?: string;
        readonly headerChunk?: string;
        readonly flags?: readonly string[];
        readonly commonChunk?: string;
        readonly uniformBufferBlocks?: string[];
        readonly textureUniforms?: readonly string[];
        readonly transformFeedback?: {
            readonly bufferMode: "INTERLEAVED_ATTRIBS" | "SEPARATE_ATTRIBS";
            readonly varyings: readonly string[];
        };
    }
}

declare module '@novorender/api/webgl2/read' {
    export function glReadPixels(gl: WebGL2RenderingContext, params: ReadPixelsParams): void;
    export interface ReadPixelsParams {
        readonly x?: number;
        readonly y?: number;
        readonly width?: number;
        readonly height?: number;
        readonly frameBuffer: WebGLFramebuffer | null;
        readonly buffers: readonly ReadPixelsBuffer[];
    }
    export interface ReadPixelsBuffer {
        readonly attachment: AttachmentType;
        readonly buffer: WebGLBuffer;
        readonly format: PixelFormat;
        readonly type: PixelType;
    }
    export interface ReadPixelsAsyncParams {
        readonly x: number;
        readonly y: number;
        readonly width?: number;
        readonly height?: number;
        readonly attachment?: AttachmentType;
        readonly format?: PixelFormat;
        readonly type?: PixelType;
    }
    export type AttachmentType = "BACK" | `COLOR_ATTACHMENT${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15}`;
    export type PixelFormat = "ALPHA" | "RGB" | "RGBA" | "RED" | "RG" | "RED_INTEGER" | "RG_INTEGER" | "RGB_INTEGER" | "RGBA_INTEGER";
    export type PixelType = "UNSIGNED_BYTE" | "UNSIGNED_SHORT_5_6_5" | "UNSIGNED_SHORT_4_4_4_4" | "UNSIGNED_SHORT_5_5_5_1" | "FLOAT" | "BYTE" | "UNSIGNED_INT_2_10_10_10_REV" | "HALF_FLOAT" | "SHORT" | "UNSIGNED_SHORT" | "INT" | "UNSIGNED_INT" | "UNSIGNED_INT_10F_11F_11F_REV" | "UNSIGNED_INT_10F_11F_11F_REV";
    export type Pixels = Float32Array | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array;
}

declare module '@novorender/api/webgl2/renderBuffer' {
    export function glCreateRenderbuffer(gl: WebGL2RenderingContext, params: RenderbufferParams): WebGLRenderbuffer;
    export type RenderBufferFormat = "R8" | "R8UI" | "R8I" | "R16UI" | "R16I" | "R32UI" | "R32I" | "RG8" | "RG8UI" | "RG8I" | "RG16UI" | "RG16I" | "RG32UI" | "RG32I" | "RGB8" | "RGBA8" | "SRGB8_ALPHA8" | "RGBA4" | "RGB565" | "RGB5_A1" | "RGB10_A2" | "RGBA8UI" | "RGBA8I" | "RGB10_A2UI" | "RGBA16UI" | "RGBA16I" | "RGBA32I" | "RGBA32UI" | "DEPTH_COMPONENT16" | "DEPTH_COMPONENT24" | "DEPTH_COMPONENT32F" | "DEPTH24_STENCIL8" | "DEPTH32F_STENCIL8" | "STENCIL_INDEX8" | "R16F" | "RG16F" | "RGBA16F" | "R32F" | "RG32F" | "RGBA32F" | "R11F_G11F_B10F";
    export interface RenderbufferParams {
        readonly internalFormat: RenderBufferFormat;
        readonly width: number;
        readonly height: number;
        readonly samples?: number | "max";
    }
}

declare module '@novorender/api/webgl2/sampler' {
    export type WrapString = "CLAMP_TO_EDGE" | "MIRRORED_REPEAT" | "REPEAT";
    export type MinFilterString = "NEAREST" | "LINEAR" | "NEAREST_MIPMAP_NEAREST" | "LINEAR_MIPMAP_NEAREST" | "NEAREST_MIPMAP_LINEAR" | "LINEAR_MIPMAP_LINEAR";
    export type MagFilterString = "NEAREST" | "LINEAR";
    export type CompareFuncString = "NEVER" | "LESS" | "EQUAL" | "LEQUAL" | "GREATER" | "NOTEQUAL" | "GEQUAL" | "ALWAYS";
    export type CompareModeString = "COMPARE_REF_TO_TEXTURE" | "NONE";
    export function glCreateSampler(gl: WebGL2RenderingContext, params: SamplerParams): WebGLSampler;
    export interface SamplerParams {
        readonly minificationFilter?: MinFilterString;
        readonly magnificationFilter?: MagFilterString;
        readonly minLOD?: number;
        readonly maxLOD?: number;
        readonly compareFunction?: CompareFuncString;
        readonly compareMode?: CompareModeString;
        readonly wrap?: readonly [WrapString, WrapString] | readonly [WrapString, WrapString, WrapString];
    }
}

declare module '@novorender/api/webgl2/state' {
    import { type LimitsGL } from "@novorender/api/webgl2/limits";
    export function glState(gl: WebGL2RenderingContext, params: StateParams | null): void;
    export function glDefaultState(limits: LimitsGL): State;
    type ScopedParamsKeys = "blend" | "cull" | "depth" | "polygon" | "sample" | "stencil" | "scissor";
    export type StateParams = Partial<Omit<State, ScopedParamsKeys>> & {
        readonly [P in ScopedParamsKeys]?: Partial<State[P]>;
    };
    export interface State {
        readonly blend: {
            readonly enable: boolean;
            readonly color: RGBA;
            readonly dstAlpha: BlendFunction;
            readonly dstRGB: BlendFunction;
            readonly equationAlpha: BlendEquation;
            readonly equationRGB: BlendEquation;
            readonly srcAlpha: BlendFunction;
            readonly srcRGB: BlendFunction;
        };
        readonly cull: {
            readonly enable: boolean;
            readonly mode: CullMode;
            readonly frontFace: Winding;
        };
        readonly depth: {
            readonly test: boolean;
            readonly func: DepthFunc;
            readonly writeMask: boolean;
            readonly range: readonly [near: number, far: number];
        };
        readonly polygon: {
            readonly offsetFill: boolean;
            readonly offsetFactor: number;
            readonly offsetUnits: number;
        };
        readonly sample: {
            readonly alphaToCoverage: boolean;
            readonly coverage: boolean;
            readonly coverageValue: number;
            readonly coverageInvert: boolean;
        };
        readonly stencil: {
            readonly test: boolean;
            readonly func: DepthFunc;
            readonly valueMask: number;
            readonly ref: number;
            readonly backFunc: DepthFunc;
            readonly backValueMask: number;
            readonly backRef: number;
        };
        readonly scissor: {
            readonly test: boolean;
            readonly box: Rect;
        };
        readonly ditherEnable: boolean;
        readonly colorMask: readonly [red: boolean, green: boolean, blue: boolean, alpha: boolean];
        readonly viewport: Rect;
        readonly rasterizerDiscard: boolean;
        readonly frameBuffer: WebGLFramebuffer | null;
        readonly vertexArrayObject: WebGLVertexArrayObject | null;
        readonly program: WebGLProgram | null;
        readonly uniforms: readonly UniformBinding[];
        readonly uniformBuffers: readonly UniformBufferBinding[];
        readonly drawBuffers: readonly (ColorAttachment | "BACK" | "NONE")[];
        readonly attributeDefaults: readonly (AttributeDefault | null)[];
        readonly textures: readonly (TextureBinding | null)[];
    }
    export type BlendEquation = "FUNC_ADD" | "FUNC_SUBTRACT" | "FUNC_REVERSE_SUBTRACT" | "MIN" | "MAX";
    export type BlendFunction = "ZERO" | "ONE" | "SRC_COLOR" | "ONE_MINUS_SRC_COLOR" | "DST_COLOR" | "ONE_MINUS_DST_COLOR" | "SRC_ALPHA" | "ONE_MINUS_SRC_ALPHA" | "DST_ALPHA" | "ONE_MINUS_DST_ALPHA" | "CONSTANT_COLOR" | "ONE_MINUS_CONSTANT_COLOR" | "CONSTANT_ALPHA" | "ONE_MINUS_CONSTANT_ALPHA" | "SRC_ALPHA_SATURATE";
    export type CullMode = "FRONT" | "BACK" | "FRONT_AND_BACK";
    export type DepthFunc = "NEVER" | "LESS" | "EQUAL" | "LEQUAL" | "GREATER" | "NOTEQUAL" | "GEQUAL" | "ALWAYS";
    export type Winding = "CW" | "CCW";
    export type ColorAttachment = `COLOR_ATTACHMENT${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15}`;
    export type RGBA = readonly [r: number, g: number, b: number, a: number];
    export type XYZW = readonly [x: number, y: number, z: number, w: number];
    export interface Rect {
        readonly x?: number;
        readonly y?: number;
        readonly width: number;
        readonly height: number;
    }
    export interface AttributeDefault {
        readonly type: "4f" | "I4i" | "I4ui";
        readonly values: XYZW;
    }
    export interface AttributeBinding {
        readonly type: "4f" | "I4i" | "I4ui";
        readonly values: XYZW;
    }
    export type UniformTypeScalar = "1f" | "1i" | "1ui";
    export type UniformTypeVector = "2f" | "3f" | "4f" | "2i" | "3i" | "4i" | "2ui" | "3ui" | "4ui";
    export type UniformTypeMatrix = "Matrix2f" | "Matrix3f" | "Matrix4f" | "Matrix2x3f" | "Matrix2x4f" | "Matrix3x2f" | "Matrix3x4f" | "Matrix4x2f" | "Matrix4x3f";
    export interface UniformBindingScalar {
        readonly kind: UniformTypeScalar;
        readonly location: WebGLUniformLocation | null;
        readonly value: number;
    }
    export interface UniformBindingVector {
        readonly kind: UniformTypeVector;
        readonly location: WebGLUniformLocation | null;
        readonly value: readonly number[];
    }
    export interface UniformBindingMatrix {
        readonly kind: UniformTypeMatrix;
        readonly location: WebGLUniformLocation | null;
        readonly value: readonly number[];
        readonly transpose?: boolean;
    }
    export type UniformBinding = UniformBindingScalar | UniformBindingVector | UniformBindingMatrix;
    export interface UniformBufferBindingRange {
        readonly buffer: WebGLBuffer;
        readonly byteOffset: number;
        readonly byteSize: number;
    }
    export type UniformBufferBinding = UniformBufferBindingRange | WebGLBuffer | null | undefined;
    export interface TextureBinding {
        readonly kind: "TEXTURE_2D" | "TEXTURE_3D" | "TEXTURE_2D_ARRAY" | "TEXTURE_CUBE_MAP";
        readonly texture: WebGLTexture | null;
        readonly sampler: WebGLSampler | null;
        readonly uniform?: WebGLUniformLocation | null;
    }
    export {};
}

declare module '@novorender/api/webgl2/texture' {
    export function glCreateTexture(gl: WebGL2RenderingContext, params: TextureParams): WebGLTexture;
    export function glUpdateTexture(gl: WebGL2RenderingContext, targetTexture: WebGLTexture, params: TextureParams): void;
    export type TextureParams = TextureParams2DUncompressedImage | TextureParams2DUncompressed | TextureParams2DCompressed | TextureParams2DUncompressedMipMapped | TextureParams2DCompressedMipMapped | TextureParamsCubeUncompressed | TextureParamsCubeCompressed | TextureParamsCubeUncompressedMipMapped | TextureParamsCubeCompressedMipMapped | TextureParams3DUncompressed | TextureParams3DCompressed | TextureParams3DUncompressedMipMapped | TextureParams3DCompressedMipMapped | TextureParams2DArrayUncompressed | TextureParams2DArrayCompressed | TextureParams2DArrayUncompressedMipMapped | TextureParams2DArrayCompressedMipMapped;
    export type TextureTargetString = TextureParams["kind"];
    export type TextureImageSource = ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas;
    export type TextureParams2DUncompressedImage = Uncompressed & Partial<Size2D> & GenMipMap & {
        readonly kind: "TEXTURE_2D";
        readonly image: TextureImageSource;
    };
    export type TextureParams2DUncompressed = Uncompressed & Size2D & GenMipMap & {
        readonly kind: "TEXTURE_2D";
        readonly image: BufferSource | TextureImageSource | null;
    };
    export interface TextureParams2DCompressed extends Compressed, Size2D {
        readonly kind: "TEXTURE_2D";
        readonly image: BufferSource;
    }
    export type TextureParams2DUncompressedMipMapped = Uncompressed & Size2D<Pow2> & GenMipMap & {
        readonly kind: "TEXTURE_2D";
        readonly mipMaps: number | readonly (BufferSource | null)[];
    };
    export interface TextureParams2DCompressedMipMapped extends Compressed, Size2D<Pow2> {
        readonly kind: "TEXTURE_2D";
        readonly mipMaps: readonly (BufferSource)[];
    }
    export type TextureParamsCubeUncompressed = Uncompressed & Size2D & GenMipMap & {
        readonly kind: "TEXTURE_CUBE_MAP";
        readonly image: CubeImages | null;
    };
    export interface TextureParamsCubeCompressed extends Compressed, Size2D {
        readonly kind: "TEXTURE_CUBE_MAP";
        readonly image: CubeImages;
    }
    export type TextureParamsCubeUncompressedMipMapped = Uncompressed & Size2D<Pow2> & {
        readonly kind: "TEXTURE_CUBE_MAP";
        readonly mipMaps: number | readonly (CubeImages | null)[];
    };
    export interface TextureParamsCubeCompressedMipMapped extends Compressed, Size2D<Pow2> {
        readonly kind: "TEXTURE_CUBE_MAP";
        readonly mipMaps: readonly (CubeImages)[];
    }
    export type TextureParams3DUncompressed = Uncompressed & Size3D & GenMipMap & {
        readonly kind: "TEXTURE_3D";
        readonly image: BufferSource | null;
    };
    export interface TextureParams3DCompressed extends Compressed, Size3D {
        readonly kind: "TEXTURE_3D";
        readonly image: BufferSource;
    }
    export type TextureParams3DUncompressedMipMapped = Uncompressed & Size3D<Pow2> & {
        readonly kind: "TEXTURE_3D";
        readonly mipMaps: number | readonly (BufferSource | null)[];
    };
    export interface TextureParams3DCompressedMipMapped extends Compressed, Size3D<Pow2> {
        readonly kind: "TEXTURE_3D";
        readonly mipMaps: readonly (BufferSource)[];
    }
    export type TextureParams2DArrayUncompressed = Uncompressed & Size3D & GenMipMap & {
        readonly kind: "TEXTURE_2D_ARRAY";
        readonly image: BufferSource | null;
    };
    export interface TextureParams2DArrayCompressed extends Compressed, Size3D {
        readonly kind: "TEXTURE_2D_ARRAY";
        readonly image: BufferSource;
    }
    export type TextureParams2DArrayUncompressedMipMapped = Uncompressed & Size3D<Pow2> & {
        readonly kind: "TEXTURE_2D_ARRAY";
        readonly mipMaps: number | readonly (BufferSource | null)[];
    };
    export interface TextureParams2DArrayCompressedMipMapped extends Compressed, Size3D<Pow2> {
        readonly kind: "TEXTURE_2D_ARRAY";
        readonly mipMaps: readonly (BufferSource)[];
    }
    export type TextureImageTargetString = "TEXTURE_2D" | "TEXTURE_3D" | "TEXTURE_2D_ARRAY" | "TEXTURE_CUBE_MAP_POSITIVE_X" | "TEXTURE_CUBE_MAP_NEGATIVE_X" | "TEXTURE_CUBE_MAP_POSITIVE_Y" | "TEXTURE_CUBE_MAP_NEGATIVE_Y" | "TEXTURE_CUBE_MAP_POSITIVE_Z" | "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    export type UncompressedTextureFormatType = {
        internalFormat: "R8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "R8_SNORM";
        type: "BYTE";
    } | {
        internalFormat: "R16F";
        type: "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "R32F";
        type: "FLOAT";
    } | {
        internalFormat: "R8UI";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "R8I";
        type: "BYTE";
    } | {
        internalFormat: "R16UI";
        type: "UNSIGNED_SHORT";
    } | {
        internalFormat: "R16I";
        type: "SHORT";
    } | {
        internalFormat: "R32UI";
        type: "UNSIGNED_INT";
    } | {
        internalFormat: "R32I";
        type: "INT";
    } | {
        internalFormat: "RG8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RG8_SNORM";
        type: "BYTE";
    } | {
        internalFormat: "RG16F";
        type: "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "RG32F";
        type: "FLOAT";
    } | {
        internalFormat: "RG8UI";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RG8I";
        type: "BYTE";
    } | {
        internalFormat: "RG16UI";
        type: "UNSIGNED_SHORT";
    } | {
        internalFormat: "RG16I";
        type: "SHORT";
    } | {
        internalFormat: "RG32UI";
        type: "UNSIGNED_INT";
    } | {
        internalFormat: "RG32I";
        type: "INT";
    } | {
        internalFormat: "RGB8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "SRGB8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RGB565";
        type: "UNSIGNED_BYTE" | "UNSIGNED_SHORT_5_6_5";
    } | {
        internalFormat: "RGB8_SNORM";
        type: "BYTE";
    } | {
        internalFormat: "R11F_G11F_B10F";
        type: "UNSIGNED_INT_10F_11F_11F_REV" | "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "RGB9_E5";
        type: "UNSIGNED_INT_5_9_9_9_REV" | "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "RGB16F";
        type: "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "RGB32F";
        type: "FLOAT";
    } | {
        internalFormat: "RGB8UI";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RGB8I";
        type: "BYTE";
    } | {
        internalFormat: "RGB16UI";
        type: "UNSIGNED_SHORT";
    } | {
        internalFormat: "RGB16I";
        type: "SHORT";
    } | {
        internalFormat: "RGB32UI";
        type: "UNSIGNED_INT";
    } | {
        internalFormat: "RGB32I";
        type: "INT";
    } | {
        internalFormat: "RGBA8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "SRGB8_ALPHA8";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RGBA8_SNORM";
        type: "BYTE";
    } | {
        internalFormat: "RGB5_A1";
        type: "UNSIGNED_BYTE" | "UNSIGNED_SHORT_5_5_5_1" | "UNSIGNED_INT_2_10_10_10_REV";
    } | {
        internalFormat: "RGBA4";
        type: "UNSIGNED_BYTE" | "UNSIGNED_SHORT_4_4_4_4";
    } | {
        internalFormat: "RGB10_A2";
        type: "UNSIGNED_INT_2_10_10_10_REV";
    } | {
        internalFormat: "RGBA16F";
        type: "HALF_FLOAT" | "FLOAT";
    } | {
        internalFormat: "RGBA32F";
        type: "FLOAT";
    } | {
        internalFormat: "RGBA8UI";
        type: "UNSIGNED_BYTE";
    } | {
        internalFormat: "RGBA8I";
        type: "BYTE";
    } | {
        internalFormat: "RGB10_A2UI";
        type: "UNSIGNED_INT_2_10_10_10_REV";
    } | {
        internalFormat: "RGBA16UI";
        type: "UNSIGNED_SHORT";
    } | {
        internalFormat: "RGBA16I";
        type: "SHORT";
    } | {
        internalFormat: "RGBA32I";
        type: "INT";
    } | {
        internalFormat: "RGBA32UI";
        type: "UNSIGNED_INT";
    } | {
        internalFormat: "DEPTH_COMPONENT16";
        type: "UNSIGNED_SHORT";
    } | {
        internalFormat: "DEPTH_COMPONENT24";
        type: "UNSIGNED_INT";
    } | {
        internalFormat: "DEPTH_COMPONENT32F";
        type: "FLOAT";
    } | {
        internalFormat: "DEPTH24_STENCIL8";
        type: "UNSIGNED_INT_24_8";
    } | {
        internalFormat: "DEPTH32F_STENCIL8";
        type: "FLOAT_32_UNSIGNED_INT_24_8_REV";
    };
    export type UncompressedTextureFormatString = UncompressedTextureFormatType["internalFormat"];
    export type TexelTypeString = UncompressedTextureFormatType["type"];
    export type CompressedTextureFormatString = "COMPRESSED_RGB_S3TC_DXT1_EXT" | "COMPRESSED_RGBA_S3TC_DXT1_EXT" | "COMPRESSED_RGBA_S3TC_DXT3_EXT" | "COMPRESSED_RGBA_S3TC_DXT5_EXT" | "COMPRESSED_SRGB_S3TC_DXT1_EXT" | "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT" | "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT" | "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT" | "COMPRESSED_R11_EAC" | "COMPRESSED_SIGNED_R11_EAC" | "COMPRESSED_RG11_EAC" | "COMPRESSED_SIGNED_RG11_EAC" | "COMPRESSED_RGB8_ETC2" | "COMPRESSED_RGBA8_ETC2_EAC" | "COMPRESSED_SRGB8_ETC2" | "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC" | "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2" | "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2" | "COMPRESSED_RGB_PVRTC_4BPPV1_IMG" | "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG" | "COMPRESSED_RGB_PVRTC_2BPPV1_IMG" | "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG" | "COMPRESSED_RGB_ETC1_WEBGL" | "COMPRESSED_RGBA_ASTC_4x4_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR" | "COMPRESSED_RGBA_ASTC_5x4_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR" | "COMPRESSED_RGBA_ASTC_5x5_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR" | "COMPRESSED_RGBA_ASTC_6x5_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR" | "COMPRESSED_RGBA_ASTC_6x6_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR" | "COMPRESSED_RGBA_ASTC_8x5_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR" | "COMPRESSED_RGBA_ASTC_8x6_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR" | "COMPRESSED_RGBA_ASTC_8x8_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR" | "COMPRESSED_RGBA_ASTC_10x5_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR" | "COMPRESSED_RGBA_ASTC_10x6_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR" | "COMPRESSED_RGBA_ASTC_10x10_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR" | "COMPRESSED_RGBA_ASTC_12x10_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR" | "COMPRESSED_RGBA_ASTC_12x12_KHR" | "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR" | "COMPRESSED_RGBA_BPTC_UNORM_EXT" | "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT" | "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT" | "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT" | "COMPRESSED_RED_RGTC1_EXT" | "COMPRESSED_SIGNED_RED_RGTC1_EXT" | "COMPRESSED_RED_GREEN_RGTC2_EXT" | "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    export type Pow2 = 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32758 | 65536;
    export type CubeImages = readonly [posX: BufferSource, negX: BufferSource, posY: BufferSource, negZ: BufferSource, posZ: BufferSource, negZ: BufferSource];
    type Uncompressed = UncompressedTextureFormatType;
    interface Compressed {
        readonly internalFormat: CompressedTextureFormatString;
    }
    interface GenMipMap {
        readonly generateMipMaps?: boolean;
    }
    interface Size2D<T extends number = number> {
        readonly width: T;
        readonly height: T;
    }
    interface Size3D<T extends number = number> {
        readonly width: T;
        readonly height: T;
        readonly depth: T;
    }
    export {};
}

declare module '@novorender/api/webgl2/timer' {
    import { type EXT_disjoint_timer_query_webgl2_ext } from "@novorender/api/webgl2/extensions";
    export function glCreateTimer(gl: WebGL2RenderingContext, cpuFallback?: boolean): Timer;
    export type Timer = NullTimer | CPUTimer | GPUTimer | GPUTimerTS;
    class NullTimer {
        readonly gl: WebGL2RenderingContext;
        readonly kind = "null";
        readonly promise: Promise<number | undefined>;
        readonly creationTime: number;
        constructor(gl: WebGL2RenderingContext);
        dispose(): void;
        begin(): void;
        end(): void;
        poll(): boolean;
    }
    class CPUTimer {
        readonly gl: WebGL2RenderingContext;
        readonly kind = "cpu";
        readonly promise: Promise<number | undefined>;
        readonly creationTime: number;
        constructor(gl: WebGL2RenderingContext);
        dispose(): void;
        begin(): void;
        end(): void;
        poll(): boolean;
    }
    class GPUTimer {
        readonly gl: WebGL2RenderingContext;
        readonly ext: EXT_disjoint_timer_query_webgl2_ext;
        readonly kind = "gpu_time_elapsed";
        readonly promise: Promise<number | undefined>;
        readonly creationTime: number;
        constructor(gl: WebGL2RenderingContext, ext: EXT_disjoint_timer_query_webgl2_ext);
        dispose(): void;
        begin(): void;
        end(): void;
        poll(): boolean;
    }
    class GPUTimerTS {
        readonly gl: WebGL2RenderingContext;
        readonly ext: EXT_disjoint_timer_query_webgl2_ext;
        readonly kind = "gpu_timestamp";
        readonly promise: Promise<number | undefined>;
        readonly creationTime: number;
        constructor(gl: WebGL2RenderingContext, ext: EXT_disjoint_timer_query_webgl2_ext);
        dispose(): void;
        begin(): void;
        end(): void;
        poll(): boolean;
    }
    export {};
}

declare module '@novorender/api/webgl2/transformFeedback' {
    export function glTransformFeedback(gl: WebGL2RenderingContext, params: TransformFeedbackParams): void;
    export type TransformFeedbackPrimitiveMode = "POINTS" | "LINES" | "TRIANGLES";
    export interface TransformFeedbackParams {
        readonly kind: TransformFeedbackPrimitiveMode;
        readonly count: number;
        readonly first?: number;
        readonly transformFeedback: WebGLTransformFeedback;
        readonly outputBuffers: readonly WebGLBuffer[];
    }
}

declare module '@novorender/api/webgl2/uniforms' {
    import { GL } from "@novorender/api/webgl2/constants";
    export function glGetUniformsInfo(gl: WebGL2RenderingContext, program: WebGLProgram): readonly UniformInfo[];
    export function glGetUniformBlocks(gl: WebGL2RenderingContext, program: WebGLProgram): (string | null)[];
    export type UniformType = GL.FLOAT | GL.FLOAT_VEC2 | GL.FLOAT_VEC3 | GL.FLOAT_VEC4 | GL.INT | GL.INT_VEC2 | GL.INT_VEC3 | GL.INT_VEC4 | GL.UNSIGNED_INT | GL.UNSIGNED_INT_VEC2 | GL.UNSIGNED_INT_VEC3 | GL.UNSIGNED_INT_VEC4 | GL.BOOL | GL.BOOL_VEC2 | GL.BOOL_VEC3 | GL.BOOL_VEC4 | GL.FLOAT_MAT2 | GL.FLOAT_MAT3 | GL.FLOAT_MAT4 | GL.FLOAT_MAT2x3 | GL.FLOAT_MAT2x4 | GL.FLOAT_MAT3x2 | GL.FLOAT_MAT3x4 | GL.FLOAT_MAT4x2 | GL.FLOAT_MAT4x3 | GL.SAMPLER_2D | GL.SAMPLER_2D_ARRAY | GL.SAMPLER_2D_ARRAY_SHADOW | GL.SAMPLER_2D_ARRAY_SHADOW | GL.SAMPLER_3D | GL.SAMPLER_CUBE | GL.SAMPLER_CUBE_SHADOW;
    export interface UniformInfo {
        readonly name: string;
        readonly type: UniformType;
        readonly size: number;
        readonly blockIndex: number;
        readonly offset: number;
    }
    export function glUniformLocations<const T extends readonly string[]>(gl: WebGL2RenderingContext, program: WebGLProgram, names: T, prefix?: string): Record<T[number], WebGLUniformLocation | null>;
    export function glUBOProxy<const T extends Record<string, UniformTypes>>(values: T): {
        readonly buffer: ArrayBuffer;
        readonly dirtyRange: DirtyRange;
        readonly values: { [P in Extract<keyof T, string>]: T[P] extends "bool" ? boolean : T[P] extends "float" | "int" | "uint" ? number : ArrayLike<number>; };
    };
    class DirtyRange {
        readonly size: number;
        begin: number;
        end: number;
        constructor(size: number);
        get isEmpty(): boolean;
        clear(): void;
        reset(): void;
        expand(begin: number, end: number): void;
    }
    export interface UniformsProxy {
        readonly buffer: ArrayBuffer;
        readonly dirtyRange: DirtyRange;
        readonly values: {
            [index: string]: boolean | number | ArrayLike<number>;
        };
    }
    const uniformTypes: {
        readonly bool: {
            readonly type: "i32";
            readonly alignment: 1;
            readonly components: 1;
            readonly rows: 1;
        };
        readonly int: {
            readonly type: "i32";
            readonly alignment: 1;
            readonly components: 1;
            readonly rows: 1;
        };
        readonly uint: {
            readonly type: "u32";
            readonly alignment: 1;
            readonly components: 1;
            readonly rows: 1;
        };
        readonly float: {
            readonly type: "f32";
            readonly alignment: 1;
            readonly components: 1;
            readonly rows: 1;
        };
        readonly ivec2: {
            readonly type: "i32";
            readonly alignment: 2;
            readonly components: 2;
            readonly rows: 1;
        };
        readonly uvec2: {
            readonly type: "u32";
            readonly alignment: 2;
            readonly components: 2;
            readonly rows: 1;
        };
        readonly vec2: {
            readonly type: "f32";
            readonly alignment: 2;
            readonly components: 2;
            readonly rows: 1;
        };
        readonly ivec3: {
            readonly type: "i32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 1;
        };
        readonly uvec3: {
            readonly type: "u32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 1;
        };
        readonly vec3: {
            readonly type: "f32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 1;
        };
        readonly ivec4: {
            readonly type: "i32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 1;
        };
        readonly uvec4: {
            readonly type: "u32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 1;
        };
        readonly vec4: {
            readonly type: "f32";
            readonly alignment: 4;
            readonly components: 4;
            readonly rows: 1;
        };
        readonly mat3: {
            readonly type: "f32";
            readonly alignment: 4;
            readonly components: 3;
            readonly rows: 3;
        };
        readonly mat4: {
            readonly type: "f32";
            readonly alignment: 4;
            readonly components: 4;
            readonly rows: 4;
        };
    };
    export type UniformTypes = keyof typeof uniformTypes;
    export {};
}

declare module '@novorender/api/webgl2/vao' {
    export function glCreateVertexArray(gl: WebGL2RenderingContext, params: VertexArrayParams): WebGLVertexArrayObject;
    export interface VertexArrayParams {
        readonly attributes: readonly (VertexAttribute | null)[];
        readonly indices?: WebGLBuffer;
    }
    export type VertexAttribute = VertexAttributeFloat | VertexAttributeFloatNormalized | VertexAttributeInt | VertexAttributeUint;
    export type ComponentTypeFloat = "HALF_FLOAT" | "FLOAT";
    export type ComponentTypeInt = "BYTE" | "SHORT" | "INT";
    export type ComponentTypeUint = "UNSIGNED_BYTE" | "UNSIGNED_SHORT" | "UNSIGNED_INT";
    export type ComponentType = ComponentTypeFloat | ComponentTypeInt | ComponentTypeUint;
    export type ShaderTypeFloat = "FLOAT" | "FLOAT_VEC2" | "FLOAT_VEC3" | "FLOAT_VEC4" | "FLOAT_MAT2" | "FLOAT_MAT3" | "FLOAT_MAT4" | "FLOAT_MAT2x3" | "FLOAT_MAT2x4" | "FLOAT_MAT3x2" | "FLOAT_MAT3x4" | "FLOAT_MAT4x2" | "FLOAT_MAT4x3";
    export type ShaderTypeInt = "INT" | "INT_VEC2" | "INT_VEC3" | "INT_VEC4";
    export type ShaderTypeUint = "UNSIGNED_INT" | "UNSIGNED_INT_VEC2" | "UNSIGNED_INT_VEC3" | "UNSIGNED_INT_VEC4";
    export type ShaderAttributeType = ShaderTypeFloat | ShaderTypeInt | ShaderTypeUint;
    interface VertexAttributeCommon {
        readonly buffer: WebGLBuffer;
        readonly componentCount?: 1 | 2 | 3 | 4;
        readonly byteStride?: number;
        readonly byteOffset?: number;
        readonly divisor?: number;
    }
    export interface VertexAttributeFloat extends VertexAttributeCommon {
        readonly kind: ShaderTypeFloat;
        readonly componentType?: ComponentType;
        readonly normalized?: false;
    }
    export interface VertexAttributeFloatNormalized extends VertexAttributeCommon {
        readonly kind: ShaderTypeFloat;
        readonly componentType?: ComponentTypeInt | ComponentTypeUint;
        readonly normalized: true;
    }
    export interface VertexAttributeInt extends VertexAttributeCommon {
        readonly kind: ShaderTypeInt;
        readonly componentType?: ComponentTypeInt;
        readonly normalized?: undefined;
    }
    export {};
}

declare module '@novorender/api/webgl2/constants' {
    export const enum GL {
        DEPTH_BUFFER_BIT = 256,
        STENCIL_BUFFER_BIT = 1024,
        COLOR_BUFFER_BIT = 16384,
        POINTS = 0,
        LINES = 1,
        LINE_LOOP = 2,
        LINE_STRIP = 3,
        TRIANGLES = 4,
        TRIANGLE_STRIP = 5,
        TRIANGLE_FAN = 6,
        ZERO = 0,
        ONE = 1,
        SRC_COLOR = 768,
        ONE_MINUS_SRC_COLOR = 769,
        SRC_ALPHA = 770,
        ONE_MINUS_SRC_ALPHA = 771,
        DST_ALPHA = 772,
        ONE_MINUS_DST_ALPHA = 773,
        DST_COLOR = 774,
        ONE_MINUS_DST_COLOR = 775,
        SRC_ALPHA_SATURATE = 776,
        CONSTANT_COLOR = 32769,
        ONE_MINUS_CONSTANT_COLOR = 32770,
        CONSTANT_ALPHA = 32771,
        ONE_MINUS_CONSTANT_ALPHA = 32772,
        FUNC_ADD = 32774,
        FUNC_SUBTRACT = 32778,
        FUNC_REVERSE_SUBTRACT = 32779,
        BLEND_EQUATION = 32777,
        BLEND_EQUATION_RGB = 32777,
        BLEND_EQUATION_ALPHA = 34877,
        BLEND_DST_RGB = 32968,
        BLEND_SRC_RGB = 32969,
        BLEND_DST_ALPHA = 32970,
        BLEND_SRC_ALPHA = 32971,
        BLEND_COLOR = 32773,
        ARRAY_BUFFER_BINDING = 34964,
        ELEMENT_ARRAY_BUFFER_BINDING = 34965,
        LINE_WIDTH = 2849,
        ALIASED_POINT_SIZE_RANGE = 33901,
        ALIASED_LINE_WIDTH_RANGE = 33902,
        CULL_FACE_MODE = 2885,
        FRONT_FACE = 2886,
        DEPTH_RANGE = 2928,
        DEPTH_WRITEMASK = 2930,
        DEPTH_CLEAR_VALUE = 2931,
        DEPTH_FUNC = 2932,
        STENCIL_CLEAR_VALUE = 2961,
        STENCIL_FUNC = 2962,
        STENCIL_FAIL = 2964,
        STENCIL_PASS_DEPTH_FAIL = 2965,
        STENCIL_PASS_DEPTH_PASS = 2966,
        STENCIL_REF = 2967,
        STENCIL_VALUE_MASK = 2963,
        STENCIL_WRITEMASK = 2968,
        STENCIL_BACK_FUNC = 34816,
        STENCIL_BACK_FAIL = 34817,
        STENCIL_BACK_PASS_DEPTH_FAIL = 34818,
        STENCIL_BACK_PASS_DEPTH_PASS = 34819,
        STENCIL_BACK_REF = 36003,
        STENCIL_BACK_VALUE_MASK = 36004,
        STENCIL_BACK_WRITEMASK = 36005,
        VIEWPORT = 2978,
        SCISSOR_BOX = 3088,
        COLOR_CLEAR_VALUE = 3106,
        COLOR_WRITEMASK = 3107,
        UNPACK_ALIGNMENT = 3317,
        PACK_ALIGNMENT = 3333,
        MAX_TEXTURE_SIZE = 3379,
        MAX_VIEWPORT_DIMS = 3386,
        SUBPIXEL_BITS = 3408,
        RED_BITS = 3410,
        GREEN_BITS = 3411,
        BLUE_BITS = 3412,
        ALPHA_BITS = 3413,
        DEPTH_BITS = 3414,
        STENCIL_BITS = 3415,
        POLYGON_OFFSET_UNITS = 10752,
        POLYGON_OFFSET_FACTOR = 32824,
        TEXTURE_BINDING_2D = 32873,
        SAMPLE_BUFFERS = 32936,
        SAMPLES = 32937,
        SAMPLE_COVERAGE_VALUE = 32938,
        SAMPLE_COVERAGE_INVERT = 32939,
        COMPRESSED_TEXTURE_FORMATS = 34467,
        VENDOR = 7936,
        RENDERER = 7937,
        VERSION = 7938,
        IMPLEMENTATION_COLOR_READ_TYPE = 35738,
        IMPLEMENTATION_COLOR_READ_FORMAT = 35739,
        BROWSER_DEFAULT_WEBGL = 37444,
        STATIC_DRAW = 35044,
        STREAM_DRAW = 35040,
        DYNAMIC_DRAW = 35048,
        ARRAY_BUFFER = 34962,
        ELEMENT_ARRAY_BUFFER = 34963,
        BUFFER_SIZE = 34660,
        BUFFER_USAGE = 34661,
        CURRENT_VERTEX_ATTRIB = 34342,
        VERTEX_ATTRIB_ARRAY_ENABLED = 34338,
        VERTEX_ATTRIB_ARRAY_SIZE = 34339,
        VERTEX_ATTRIB_ARRAY_STRIDE = 34340,
        VERTEX_ATTRIB_ARRAY_TYPE = 34341,
        VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922,
        VERTEX_ATTRIB_ARRAY_POINTER = 34373,
        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975,
        CULL_FACE = 2884,
        FRONT = 1028,
        BACK = 1029,
        FRONT_AND_BACK = 1032,
        BLEND = 3042,
        DEPTH_TEST = 2929,
        DITHER = 3024,
        POLYGON_OFFSET_FILL = 32823,
        SAMPLE_ALPHA_TO_COVERAGE = 32926,
        SAMPLE_COVERAGE = 32928,
        SCISSOR_TEST = 3089,
        STENCIL_TEST = 2960,
        NO_ERROR = 0,
        INVALID_ENUM = 1280,
        INVALID_VALUE = 1281,
        INVALID_OPERATION = 1282,
        OUT_OF_MEMORY = 1285,
        CONTEXT_LOST_WEBGL = 37442,
        CW = 2304,
        CCW = 2305,
        DONT_CARE = 4352,
        FASTEST = 4353,
        NICEST = 4354,
        GENERATE_MIPMAP_HINT = 33170,
        BYTE = 5120,
        UNSIGNED_BYTE = 5121,
        SHORT = 5122,
        UNSIGNED_SHORT = 5123,
        INT = 5124,
        UNSIGNED_INT = 5125,
        FLOAT = 5126,
        DEPTH_COMPONENT = 6402,
        ALPHA = 6406,
        RGB = 6407,
        RGBA = 6408,
        LUMINANCE = 6409,
        LUMINANCE_ALPHA = 6410,
        UNSIGNED_SHORT_4_4_4_4 = 32819,
        UNSIGNED_SHORT_5_5_5_1 = 32820,
        UNSIGNED_SHORT_5_6_5 = 33635,
        FRAGMENT_SHADER = 35632,
        VERTEX_SHADER = 35633,
        COMPILE_STATUS = 35713,
        DELETE_STATUS = 35712,
        LINK_STATUS = 35714,
        VALIDATE_STATUS = 35715,
        ATTACHED_SHADERS = 35717,
        ACTIVE_ATTRIBUTES = 35721,
        ACTIVE_UNIFORMS = 35718,
        MAX_VERTEX_ATTRIBS = 34921,
        MAX_VERTEX_UNIFORM_VECTORS = 36347,
        MAX_VARYING_VECTORS = 36348,
        MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661,
        MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660,
        MAX_TEXTURE_IMAGE_UNITS = 34930,
        MAX_FRAGMENT_UNIFORM_VECTORS = 36349,
        SHADER_TYPE = 35663,
        SHADING_LANGUAGE_VERSION = 35724,
        CURRENT_PROGRAM = 35725,
        NEVER = 512,
        LESS = 513,
        EQUAL = 514,
        LEQUAL = 515,
        GREATER = 516,
        NOTEQUAL = 517,
        GEQUAL = 518,
        ALWAYS = 519,
        KEEP = 7680,
        REPLACE = 7681,
        INCR = 7682,
        DECR = 7683,
        INVERT = 5386,
        INCR_WRAP = 34055,
        DECR_WRAP = 34056,
        NEAREST = 9728,
        LINEAR = 9729,
        NEAREST_MIPMAP_NEAREST = 9984,
        LINEAR_MIPMAP_NEAREST = 9985,
        NEAREST_MIPMAP_LINEAR = 9986,
        LINEAR_MIPMAP_LINEAR = 9987,
        TEXTURE_MAG_FILTER = 10240,
        TEXTURE_MIN_FILTER = 10241,
        TEXTURE_WRAP_S = 10242,
        TEXTURE_WRAP_T = 10243,
        TEXTURE_2D = 3553,
        TEXTURE = 5890,
        TEXTURE_CUBE_MAP = 34067,
        TEXTURE_BINDING_CUBE_MAP = 34068,
        TEXTURE_CUBE_MAP_POSITIVE_X = 34069,
        TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,
        TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,
        TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,
        TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,
        TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,
        MAX_CUBE_MAP_TEXTURE_SIZE = 34076,
        TEXTURE0 = 33984,
        TEXTURE1 = 33985,
        TEXTURE2 = 33986,
        TEXTURE3 = 33987,
        TEXTURE4 = 33988,
        TEXTURE5 = 33989,
        TEXTURE6 = 33990,
        TEXTURE7 = 33991,
        TEXTURE8 = 33992,
        TEXTURE9 = 33993,
        TEXTURE10 = 33994,
        TEXTURE11 = 33995,
        TEXTURE12 = 33996,
        TEXTURE13 = 33997,
        TEXTURE14 = 33998,
        TEXTURE15 = 33999,
        TEXTURE16 = 34000,
        TEXTURE17 = 34001,
        TEXTURE18 = 34002,
        TEXTURE19 = 34003,
        TEXTURE20 = 34004,
        TEXTURE21 = 34005,
        TEXTURE22 = 34006,
        TEXTURE23 = 34007,
        TEXTURE24 = 34008,
        TEXTURE25 = 34009,
        TEXTURE26 = 34010,
        TEXTURE27 = 34011,
        TEXTURE28 = 34012,
        TEXTURE29 = 34013,
        TEXTURE30 = 34014,
        TEXTURE31 = 34015,
        ACTIVE_TEXTURE = 34016,
        REPEAT = 10497,
        CLAMP_TO_EDGE = 33071,
        MIRRORED_REPEAT = 33648,
        FLOAT_VEC2 = 35664,
        FLOAT_VEC3 = 35665,
        FLOAT_VEC4 = 35666,
        INT_VEC2 = 35667,
        INT_VEC3 = 35668,
        INT_VEC4 = 35669,
        BOOL = 35670,
        BOOL_VEC2 = 35671,
        BOOL_VEC3 = 35672,
        BOOL_VEC4 = 35673,
        FLOAT_MAT2 = 35674,
        FLOAT_MAT3 = 35675,
        FLOAT_MAT4 = 35676,
        SAMPLER_2D = 35678,
        SAMPLER_CUBE = 35680,
        LOW_FLOAT = 36336,
        MEDIUM_FLOAT = 36337,
        HIGH_FLOAT = 36338,
        LOW_INT = 36339,
        MEDIUM_INT = 36340,
        HIGH_INT = 36341,
        FRAMEBUFFER = 36160,
        RENDERBUFFER = 36161,
        RGBA4 = 32854,
        RGB5_A1 = 32855,
        RGB565 = 36194,
        DEPTH_COMPONENT16 = 33189,
        STENCIL_INDEX8 = 36168,
        DEPTH_STENCIL = 34041,
        RENDERBUFFER_WIDTH = 36162,
        RENDERBUFFER_HEIGHT = 36163,
        RENDERBUFFER_INTERNAL_FORMAT = 36164,
        RENDERBUFFER_RED_SIZE = 36176,
        RENDERBUFFER_GREEN_SIZE = 36177,
        RENDERBUFFER_BLUE_SIZE = 36178,
        RENDERBUFFER_ALPHA_SIZE = 36179,
        RENDERBUFFER_DEPTH_SIZE = 36180,
        RENDERBUFFER_STENCIL_SIZE = 36181,
        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048,
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051,
        COLOR_ATTACHMENT0 = 36064,
        DEPTH_ATTACHMENT = 36096,
        STENCIL_ATTACHMENT = 36128,
        DEPTH_STENCIL_ATTACHMENT = 33306,
        NONE = 0,
        FRAMEBUFFER_COMPLETE = 36053,
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054,
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055,
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057,
        FRAMEBUFFER_UNSUPPORTED = 36061,
        FRAMEBUFFER_BINDING = 36006,
        RENDERBUFFER_BINDING = 36007,
        MAX_RENDERBUFFER_SIZE = 34024,
        INVALID_FRAMEBUFFER_OPERATION = 1286,
        UNPACK_FLIP_Y_WEBGL = 37440,
        UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441,
        UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443,
        READ_BUFFER = 3074,
        UNPACK_ROW_LENGTH = 3314,
        UNPACK_SKIP_ROWS = 3315,
        UNPACK_SKIP_PIXELS = 3316,
        PACK_ROW_LENGTH = 3330,
        PACK_SKIP_ROWS = 3331,
        PACK_SKIP_PIXELS = 3332,
        TEXTURE_BINDING_3D = 32874,
        UNPACK_SKIP_IMAGES = 32877,
        UNPACK_IMAGE_HEIGHT = 32878,
        MAX_3D_TEXTURE_SIZE = 32883,
        MAX_ELEMENTS_VERTICES = 33000,
        MAX_ELEMENTS_INDICES = 33001,
        MAX_TEXTURE_LOD_BIAS = 34045,
        MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657,
        MAX_VERTEX_UNIFORM_COMPONENTS = 35658,
        MAX_ARRAY_TEXTURE_LAYERS = 35071,
        MIN_PROGRAM_TEXEL_OFFSET = 35076,
        MAX_PROGRAM_TEXEL_OFFSET = 35077,
        MAX_VARYING_COMPONENTS = 35659,
        FRAGMENT_SHADER_DERIVATIVE_HINT = 35723,
        RASTERIZER_DISCARD = 35977,
        VERTEX_ARRAY_BINDING = 34229,
        MAX_VERTEX_OUTPUT_COMPONENTS = 37154,
        MAX_FRAGMENT_INPUT_COMPONENTS = 37157,
        MAX_SERVER_WAIT_TIMEOUT = 37137,
        MAX_ELEMENT_INDEX = 36203,
        RED = 6403,
        RGB8 = 32849,
        RGBA8 = 32856,
        RGB10_A2 = 32857,
        TEXTURE_3D = 32879,
        TEXTURE_WRAP_R = 32882,
        TEXTURE_MIN_LOD = 33082,
        TEXTURE_MAX_LOD = 33083,
        TEXTURE_BASE_LEVEL = 33084,
        TEXTURE_MAX_LEVEL = 33085,
        TEXTURE_COMPARE_MODE = 34892,
        TEXTURE_COMPARE_FUNC = 34893,
        SRGB = 35904,
        SRGB8 = 35905,
        SRGB8_ALPHA8 = 35907,
        COMPARE_REF_TO_TEXTURE = 34894,
        RGBA32F = 34836,
        RGB32F = 34837,
        RGBA16F = 34842,
        RGB16F = 34843,
        TEXTURE_2D_ARRAY = 35866,
        TEXTURE_BINDING_2D_ARRAY = 35869,
        R11F_G11F_B10F = 35898,
        RGB9_E5 = 35901,
        RGBA32UI = 36208,
        RGB32UI = 36209,
        RGBA16UI = 36214,
        RGB16UI = 36215,
        RGBA8UI = 36220,
        RGB8UI = 36221,
        RGBA32I = 36226,
        RGB32I = 36227,
        RGBA16I = 36232,
        RGB16I = 36233,
        RGBA8I = 36238,
        RGB8I = 36239,
        RED_INTEGER = 36244,
        RGB_INTEGER = 36248,
        RGBA_INTEGER = 36249,
        R8 = 33321,
        RG8 = 33323,
        R16F = 33325,
        R32F = 33326,
        RG16F = 33327,
        RG32F = 33328,
        R8I = 33329,
        R8UI = 33330,
        R16I = 33331,
        R16UI = 33332,
        R32I = 33333,
        R32UI = 33334,
        RG8I = 33335,
        RG8UI = 33336,
        RG16I = 33337,
        RG16UI = 33338,
        RG32I = 33339,
        RG32UI = 33340,
        R8_SNORM = 36756,
        RG8_SNORM = 36757,
        RGB8_SNORM = 36758,
        RGBA8_SNORM = 36759,
        RGB10_A2UI = 36975,
        TEXTURE_IMMUTABLE_FORMAT = 37167,
        TEXTURE_IMMUTABLE_LEVELS = 33503,
        UNSIGNED_INT_2_10_10_10_REV = 33640,
        UNSIGNED_INT_10F_11F_11F_REV = 35899,
        UNSIGNED_INT_5_9_9_9_REV = 35902,
        FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,
        UNSIGNED_INT_24_8 = 34042,
        HALF_FLOAT = 5131,
        RG = 33319,
        RG_INTEGER = 33320,
        INT_2_10_10_10_REV = 36255,
        CURRENT_QUERY = 34917,
        QUERY_RESULT = 34918,
        QUERY_RESULT_AVAILABLE = 34919,
        ANY_SAMPLES_PASSED = 35887,
        ANY_SAMPLES_PASSED_CONSERVATIVE = 36202,
        MAX_DRAW_BUFFERS = 34852,
        DRAW_BUFFER0 = 34853,
        DRAW_BUFFER1 = 34854,
        DRAW_BUFFER2 = 34855,
        DRAW_BUFFER3 = 34856,
        DRAW_BUFFER4 = 34857,
        DRAW_BUFFER5 = 34858,
        DRAW_BUFFER6 = 34859,
        DRAW_BUFFER7 = 34860,
        DRAW_BUFFER8 = 34861,
        DRAW_BUFFER9 = 34862,
        DRAW_BUFFER10 = 34863,
        DRAW_BUFFER11 = 34864,
        DRAW_BUFFER12 = 34865,
        DRAW_BUFFER13 = 34866,
        DRAW_BUFFER14 = 34867,
        DRAW_BUFFER15 = 34868,
        MAX_COLOR_ATTACHMENTS = 36063,
        COLOR_ATTACHMENT1 = 36065,
        COLOR_ATTACHMENT2 = 36066,
        COLOR_ATTACHMENT3 = 36067,
        COLOR_ATTACHMENT4 = 36068,
        COLOR_ATTACHMENT5 = 36069,
        COLOR_ATTACHMENT6 = 36070,
        COLOR_ATTACHMENT7 = 36071,
        COLOR_ATTACHMENT8 = 36072,
        COLOR_ATTACHMENT9 = 36073,
        COLOR_ATTACHMENT10 = 36074,
        COLOR_ATTACHMENT11 = 36075,
        COLOR_ATTACHMENT12 = 36076,
        COLOR_ATTACHMENT13 = 36077,
        COLOR_ATTACHMENT14 = 36078,
        COLOR_ATTACHMENT15 = 36079,
        SAMPLER_3D = 35679,
        SAMPLER_2D_SHADOW = 35682,
        SAMPLER_2D_ARRAY = 36289,
        SAMPLER_2D_ARRAY_SHADOW = 36292,
        SAMPLER_CUBE_SHADOW = 36293,
        INT_SAMPLER_2D = 36298,
        INT_SAMPLER_3D = 36299,
        INT_SAMPLER_CUBE = 36300,
        INT_SAMPLER_2D_ARRAY = 36303,
        UNSIGNED_INT_SAMPLER_2D = 36306,
        UNSIGNED_INT_SAMPLER_3D = 36307,
        UNSIGNED_INT_SAMPLER_CUBE = 36308,
        UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311,
        MAX_SAMPLES = 36183,
        SAMPLER_BINDING = 35097,
        PIXEL_PACK_BUFFER = 35051,
        PIXEL_UNPACK_BUFFER = 35052,
        PIXEL_PACK_BUFFER_BINDING = 35053,
        PIXEL_UNPACK_BUFFER_BINDING = 35055,
        COPY_READ_BUFFER = 36662,
        COPY_WRITE_BUFFER = 36663,
        COPY_READ_BUFFER_BINDING = 36662,
        COPY_WRITE_BUFFER_BINDING = 36663,
        FLOAT_MAT2x3 = 35685,
        FLOAT_MAT2x4 = 35686,
        FLOAT_MAT3x2 = 35687,
        FLOAT_MAT3x4 = 35688,
        FLOAT_MAT4x2 = 35689,
        FLOAT_MAT4x3 = 35690,
        UNSIGNED_INT_VEC2 = 36294,
        UNSIGNED_INT_VEC3 = 36295,
        UNSIGNED_INT_VEC4 = 36296,
        UNSIGNED_NORMALIZED = 35863,
        SIGNED_NORMALIZED = 36764,
        VERTEX_ATTRIB_ARRAY_INTEGER = 35069,
        VERTEX_ATTRIB_ARRAY_DIVISOR = 35070,
        TRANSFORM_FEEDBACK_BUFFER_MODE = 35967,
        MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968,
        TRANSFORM_FEEDBACK_VARYINGS = 35971,
        TRANSFORM_FEEDBACK_BUFFER_START = 35972,
        TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973,
        TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976,
        MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978,
        MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979,
        INTERLEAVED_ATTRIBS = 35980,
        SEPARATE_ATTRIBS = 35981,
        TRANSFORM_FEEDBACK_BUFFER = 35982,
        TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983,
        TRANSFORM_FEEDBACK = 36386,
        TRANSFORM_FEEDBACK_PAUSED = 36387,
        TRANSFORM_FEEDBACK_ACTIVE = 36388,
        TRANSFORM_FEEDBACK_BINDING = 36389,
        FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296,
        FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297,
        FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298,
        FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299,
        FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300,
        FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301,
        FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302,
        FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303,
        FRAMEBUFFER_DEFAULT = 33304,
        DEPTH24_STENCIL8 = 35056,
        DRAW_FRAMEBUFFER_BINDING = 36006,
        READ_FRAMEBUFFER = 36008,
        DRAW_FRAMEBUFFER = 36009,
        READ_FRAMEBUFFER_BINDING = 36010,
        RENDERBUFFER_SAMPLES = 36011,
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052,
        FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182,
        UNIFORM_BUFFER = 35345,
        UNIFORM_BUFFER_BINDING = 35368,
        UNIFORM_BUFFER_START = 35369,
        UNIFORM_BUFFER_SIZE = 35370,
        MAX_VERTEX_UNIFORM_BLOCKS = 35371,
        MAX_FRAGMENT_UNIFORM_BLOCKS = 35373,
        MAX_COMBINED_UNIFORM_BLOCKS = 35374,
        MAX_UNIFORM_BUFFER_BINDINGS = 35375,
        MAX_UNIFORM_BLOCK_SIZE = 35376,
        MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377,
        MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379,
        UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380,
        ACTIVE_UNIFORM_BLOCKS = 35382,
        UNIFORM_TYPE = 35383,
        UNIFORM_SIZE = 35384,
        UNIFORM_BLOCK_INDEX = 35386,
        UNIFORM_OFFSET = 35387,
        UNIFORM_ARRAY_STRIDE = 35388,
        UNIFORM_MATRIX_STRIDE = 35389,
        UNIFORM_IS_ROW_MAJOR = 35390,
        UNIFORM_BLOCK_BINDING = 35391,
        UNIFORM_BLOCK_DATA_SIZE = 35392,
        UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394,
        UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395,
        UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396,
        UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398,
        OBJECT_TYPE = 37138,
        SYNC_CONDITION = 37139,
        SYNC_STATUS = 37140,
        SYNC_FLAGS = 37141,
        SYNC_FENCE = 37142,
        SYNC_GPU_COMMANDS_COMPLETE = 37143,
        UNSIGNALED = 37144,
        SIGNALED = 37145,
        ALREADY_SIGNALED = 37146,
        TIMEOUT_EXPIRED = 37147,
        CONDITION_SATISFIED = 37148,
        WAIT_FAILED = 37149,
        SYNC_FLUSH_COMMANDS_BIT = 1,
        COLOR = 6144,
        DEPTH = 6145,
        STENCIL = 6146,
        MIN = 32775,
        MAX = 32776,
        DEPTH_COMPONENT24 = 33190,
        STREAM_READ = 35041,
        STREAM_COPY = 35042,
        STATIC_READ = 35045,
        STATIC_COPY = 35046,
        DYNAMIC_READ = 35049,
        DYNAMIC_COPY = 35050,
        DEPTH_COMPONENT32F = 36012,
        DEPTH32F_STENCIL8 = 36013,
        INVALID_INDEX = 4294967295,
        TIMEOUT_IGNORED = -1,
        MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447,
        VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070,
        UNMASKED_VENDOR_WEBGL = 37445,
        UNMASKED_RENDERER_WEBGL = 37446,
        MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047,
        TEXTURE_MAX_ANISOTROPY_EXT = 34046,
        COMPRESSED_RGB_S3TC_DXT1_EXT = 33776,
        COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777,
        COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778,
        COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779,
        COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919,
        COMPRESSED_R11_EAC = 37488,
        COMPRESSED_SIGNED_R11_EAC = 37489,
        COMPRESSED_RG11_EAC = 37490,
        COMPRESSED_SIGNED_RG11_EAC = 37491,
        COMPRESSED_RGB8_ETC2 = 37492,
        COMPRESSED_RGBA8_ETC2_EAC = 37493,
        COMPRESSED_SRGB8_ETC2 = 37494,
        COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495,
        COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496,
        COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497,
        COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840,
        COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842,
        COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841,
        COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843,
        COMPRESSED_RGB_ETC1_WEBGL = 36196,
        COMPRESSED_RGB_ATC_WEBGL = 35986,
        COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986,
        COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798,
        UNSIGNED_INT_24_8_WEBGL = 34042,
        HALF_FLOAT_OES = 36193,
        RGBA32F_EXT = 34836,
        RGB32F_EXT = 34837,
        FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297,
        UNSIGNED_NORMALIZED_EXT = 35863,
        MIN_EXT = 32775,
        MAX_EXT = 32776,
        SRGB_EXT = 35904,
        SRGB_ALPHA_EXT = 35906,
        SRGB8_ALPHA8_EXT = 35907,
        FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 33296,
        FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723,
        COLOR_ATTACHMENT0_WEBGL = 36064,
        COLOR_ATTACHMENT1_WEBGL = 36065,
        COLOR_ATTACHMENT2_WEBGL = 36066,
        COLOR_ATTACHMENT3_WEBGL = 36067,
        COLOR_ATTACHMENT4_WEBGL = 36068,
        COLOR_ATTACHMENT5_WEBGL = 36069,
        COLOR_ATTACHMENT6_WEBGL = 36070,
        COLOR_ATTACHMENT7_WEBGL = 36071,
        COLOR_ATTACHMENT8_WEBGL = 36072,
        COLOR_ATTACHMENT9_WEBGL = 36073,
        COLOR_ATTACHMENT10_WEBGL = 36074,
        COLOR_ATTACHMENT11_WEBGL = 36075,
        COLOR_ATTACHMENT12_WEBGL = 36076,
        COLOR_ATTACHMENT13_WEBGL = 36077,
        COLOR_ATTACHMENT14_WEBGL = 36078,
        COLOR_ATTACHMENT15_WEBGL = 36079,
        DRAW_BUFFER0_WEBGL = 34853,
        DRAW_BUFFER1_WEBGL = 34854,
        DRAW_BUFFER2_WEBGL = 34855,
        DRAW_BUFFER3_WEBGL = 34856,
        DRAW_BUFFER4_WEBGL = 34857,
        DRAW_BUFFER5_WEBGL = 34858,
        DRAW_BUFFER6_WEBGL = 34859,
        DRAW_BUFFER7_WEBGL = 34860,
        DRAW_BUFFER8_WEBGL = 34861,
        DRAW_BUFFER9_WEBGL = 34862,
        DRAW_BUFFER10_WEBGL = 34863,
        DRAW_BUFFER11_WEBGL = 34864,
        DRAW_BUFFER12_WEBGL = 34865,
        DRAW_BUFFER13_WEBGL = 34866,
        DRAW_BUFFER14_WEBGL = 34867,
        DRAW_BUFFER15_WEBGL = 34868,
        MAX_COLOR_ATTACHMENTS_WEBGL = 36063,
        MAX_DRAW_BUFFERS_WEBGL = 34852,
        VERTEX_ARRAY_BINDING_OES = 34229,
        QUERY_COUNTER_BITS_EXT = 34916,
        CURRENT_QUERY_EXT = 34917,
        QUERY_RESULT_EXT = 34918,
        QUERY_RESULT_AVAILABLE_EXT = 34919,
        TIME_ELAPSED_EXT = 35007,
        TIMESTAMP_EXT = 36392,
        GPU_DISJOINT_EXT = 36795,
        COMPRESSED_RGBA_ASTC_4x4_KHR = 37808,
        COMPRESSED_RGBA_ASTC_5x4_KHR = 37809,
        COMPRESSED_RGBA_ASTC_5x5_KHR = 37810,
        COMPRESSED_RGBA_ASTC_6x5_KHR = 37811,
        COMPRESSED_RGBA_ASTC_6x6_KHR = 37812,
        COMPRESSED_RGBA_ASTC_8x5_KHR = 37813,
        COMPRESSED_RGBA_ASTC_8x6_KHR = 37814,
        COMPRESSED_RGBA_ASTC_8x8_KHR = 37815,
        COMPRESSED_RGBA_ASTC_10x5_KHR = 37816,
        COMPRESSED_RGBA_ASTC_10x6_KHR = 37817,
        COMPRESSED_RGBA_ASTC_10x8_KHR = 37818,
        COMPRESSED_RGBA_ASTC_10x10_KHR = 37819,
        COMPRESSED_RGBA_ASTC_12x10_KHR = 37820,
        COMPRESSED_RGBA_ASTC_12x12_KHR = 37821,
        COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853,
        COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492,
        COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493,
        COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494,
        COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495,
        COMPRESSED_RED_RGTC1_EXT = 36283,
        COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284,
        COMPRESSED_RED_GREEN_RGTC2_EXT = 36285,
        COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286
    }
}

